# <div align="center">

# **Язык программирования Surge**

### *Ясность. Владение. Структура. Простота — без страха.*

---

**Уроки, извлечённые из Rust, Go и Python —
но Surge не является клоном ни одного из них.
Это язык, созданный для людей, которые любят писать код,
а не для тех, кто любит сражаться с компиляторами.**

</div>

---

# Содержание

1. [Что такое Surge?](#what-is-surge)
2. [Почему Surge? (Сердце этого языка)](#why-surge)
3. [Философия дизайна](#design-philosophy)
4. [Ключевые идеи](#core-ideas)
5. [Вкус Surge — пример на 40 строк](#example)
6. [Модули и модель проекта](#modules)
7. [Инструментарий Surge](#toolchain)
8. [Контролируемая магия: система атрибутов](#attributes)
9. [Куда движется Surge (Архитектура и видение)](#future)
10. [Документация](#documentation)
11. [Статус](#status)
12. [Большое спасибо языку Go](#thanks-to-go)

---

# <a name="what-is-surge"></a>1. Что такое Surge?

**Surge — это современный системный и прикладной язык программирования** со строгими статическими гарантиями, понятными правилами владения и структурированной конкурентностью — но при этом спроектированный так, чтобы быть *простым*, *очевидным* и *дружелюбным*.

Если вы когда-нибудь мечтали, чтобы Rust был более снисходительным, Go — более выразительным, а Python — более структурированным —
Surge живёт где-то в этом треугольнике.

Он:

* строгий, но не жестокий,
* мощный, но не магический,
* безопасный по дизайну, но всё ещё ориентированный на человека.

Surge не ожидает, что вы будете инженером компиляторов.
Surge ожидает, что вы будете программистом.

Его написал человек, который такой же программист, как и вы, и знает, каково это — отлаживать код в 3 часа ночи, бороться с GC-паузой посреди бюджета на задержку или гадать, почему borrow checker сегодня выбрал насилие. Ответ Surge: **будь явным, держи правила маленькими, держи тон добрым.**

Он уважает уроки, извлечённые из этих языков — проверку заимствований из Rust, понятный инструментарий из Go и гостеприимную эргономику Python — при этом сознательно избегая их догм. Surge выбирает идеи, потому что они служат пользователю, а не потому что так постановил комитет.

---

# <a name="why-surge"></a>2. Почему Surge?

### *(Сердце этого README — читайте эту часть медленно.)*

Surge был создан из одного простого желания:

> **«Я хочу язык, который помогает мне писать хороший код —
> а не язык, который наказывает меня за то, что я не гений.»**

Давайте будем честны:
большинство современных языков впадают в две крайности:

* **слишком разрешительные** (ваши ошибки молча становятся багами),
* **или слишком строгие** (ваши ошибки превращаются в 37 ошибок компилятора и экзистенциальный кризис).

Surge пытается пойти третьим путём:

### ✔ Достаточно строгий, чтобы защитить вас.

### ✔ Достаточно простой, чтобы не пугать вас.

### ✔ Достаточно явный, чтобы учить хорошему стилю.

### ✔ Достаточно гибкий, чтобы не мешать вам.

Surge построен на нескольких осознанных решениях:

Никаких философских презентаций, никаких загадочных «лучших практик» — просто язык, который объясняет себя, пока вы печатаете. Диагностика идёт с числовыми кодами *и* практическими подсказками; трассировка встроена; компилятор хочет сотрудничать, а не допрашивать.

---

## **2.1 Нет сборщика мусора**

Не потому что GC плох — он отличный!
Но Surge — это про контроль. Предсказуемость. Явное владение памятью.

И владение не должно быть страшным.
В Surge оно *чистое, читаемое, скучное* — именно таким и должно быть.

`own T` означает «это значение моё»; `&T` означает «я только смотрю»; `&mut T` означает «я единственный, кто сейчас изменяет».
Области заимствования лексические и очевидные. Если вам нужно завершить заимствование раньше, скажите об этом явно с помощью `@drop binding;` — никаких скрытых лайфтаймов.
Только владеющие значения могут пересекать границы задач, поэтому конкурентность остаётся корректной без необходимости держать доказатель теорем в голове.

Скучное владение — лучшее владение.

---

## **2.2 Структурированная конкурентность**

Async/await в Surge предсказуем:

* задачи не переживают свою область видимости,
* никакого «task-and-forget»,
* чёткое владение между задачами (только `own T` пересекает границу),
* каналы как примитивы первого класса,
* отмена, которая действительно возвращает значение (`Cancelled`) вместо молчаливого разрушения состояния.

Это «взрослая» модель, но выраженная очень просто.

Однопоточное кооперативное планирование сегодня, путь к параллельным бэкендам завтра. Задачи — это просто значения `Task<T>`; `.await()` — это метод, а не ключевое слово; блоки `async { ... }` обеспечивают структурированную конкурентность, ожидая каждую запущенную задачу. Если вам нужно уступить управление в CPU-интенсивном цикле, `checkpoint().await()` к вашим услугам вместо надежды на вытеснение.

---

## **2.3 Никакой скрытой магии**

Surge избегает магии, кроме случаев, когда она полезна.

Единственный намеренный «аварийный выход» — это система атрибутов —
и даже там атрибуты не колдуют за вашей спиной.
Они только подсказывают компилятору, не подменяя поведение.

Даже «магические» операторы честны: операторы разрешаются в явные магические методы вроде `__index`, `__add`, `__to`; вы можете открыть stdlib и увидеть их определения. Никаких скрытых приведений, никаких неявных поисков трейтов — если язык что-то делает за вас, он говорит как.

---

## **2.4 extern<T> вместо методов внутри типов**

Surge разделяет:

* **данные** (структуры),
* **поведение** (методы во внешне объявленных пространствах имён).

Это сохраняет типы чистыми и способствует ясности:
*то, чем являются данные, не связано с тем, что данные делают.*

Блоки `extern<T>` однозначны: поля, функции, атрибуты. Никаких вложенных объявлений, никаких случайных элементов верхнего уровня. Методы диспетчеризуются статически, параметры-дженерики явные, а переопределения помечены `@override`, чтобы намерение было очевидным. Тип остаётся контейнером данных; поведение живёт рядом, а не внутри.

---

## **2.5 Контракты вместо «классов»**

Структурная типизация без церемоний.
Если ваш тип имеет требуемые поля/методы — он удовлетворяет контракту.
Никакой гимнастики с наследованием.

---

## **2.6 Язык, созданный разработчиком, а не комитетом**

Surge не пытается быть следующим Rust, или следующим Go, или следующим Zig.
Surge пытается быть **Surge**:

* честным,
* понятным,
* полезным,
* последовательным,
* и приятным для написания.

Это язык, написанный с философией:

> **«Не бойтесь ошибаться. Язык скажет вам, куда идти.»**

Так что Surge встречает вас там, где вы есть: читаемый синтаксис, ключевые слова в нижнем регистре, диагностика с контекстом и модульная система, которую можно набросать на салфетке. Цель — позволить вам сосредоточиться на архитектуре и алгоритмах, а не на умиротворении духа парсера.
Surge уважает ясность владения Rust, доступность Go и читаемость Python, при этом сознательно отказываясь копировать их компромиссы целиком.

---

# <a name="design-philosophy"></a>3. Философия дизайна

Surge руководствуется небольшим набором принципов:

### **Явное над неявным**

Если что-то происходит — вы это видите.

Аннотации типов постфиксные (`name: Type`), приведения прописаны через `to`, а модификаторы владения (`own`, `&`, `&mut`, `*`) живут в типе, а не спрятаны за сигилами. Даже сахар (`T?`, `T!`) строго только в позиции типа.

### **Абстракции с нулевой стоимостью (но понятные)**

Если что-то выглядит просто — это *и есть* просто.

Магические методы — это просто функции; контракты структурные, а не иерархии классов; асинхронные функции разворачиваются в конечные автоматы, которые вы почти могли бы написать вручную. Вы всегда можете проследить, откуда берётся производительность.

### **Ясность владения**

Если значение перемещается — это видно.
Если заимствуется — это видно.

Лайфтаймы заимствований лексические, borrow checker говорит вам, где конфликт, и только значения с `own` пересекают границы потоков или задач. Когда вам нужно завершить заимствование раньше, есть буквальный оператор `@drop expr;` вместо ритуальных заклинаний.

### **Структурированная конкурентность**

Асинхронный код не должен контрабандой попадать в память.

`async fn` возвращает `Task<T>`, `.await()` явный, `task` возвращает хэндл, который вы должны либо дождаться, либо сохранить. Никаких блуждающих задач, утекающих в пустоту. Цикл событий кооперативный, честен насчёт блокировки и готов к будущему параллельному рантайму без изменения пользовательского кода.

### **Никаких сюрпризов**

Если код выглядит так, будто должен работать — он работает.
Если Surge запрещает это, он объясняет *почему*, а не «иди подумай».

Диагностика несёт числовые коды, человеческий текст и предложения по исправлению. Трассировку можно включить, чтобы увидеть каждую фазу компиляции. Цель — прозрачность, а не хитроумность.

### **Практическая простота**

Просто ≠ тупо.
Просто означает «я понимаю, что здесь происходит».

Surge сопротивляется хитрым синтаксическим выкрутасам. Он предпочитает пару лишних символов, если они делают намерение очевидным. Это не минимализм ради самого себя; это эмпатия к читателю — включая Будущего Вас.

---

# <a name="core-ideas"></a>4. Ключевые идеи простым языком

Вот Surge на одном дыхании:

* **Владение:** предсказуемая семантика перемещения, без GC.
* **Заимствование:** понятные правила `&T` / `&mut T`.
* **Контракты:** структурные интерфейсы без церемоний.
* **Теги:** типы-суммы, они же tagged unions — встроены.
* **Async/await:** stackless-корутины + структурированная конкурентность.
* **Задачи:** время жизни родительской области, явная отмена.
* **Каналы:** примитив первого класса для асинхронных пайплайнов.
* **Extern-блоки:** определяют поведение рядом с типами, а не внутри них.
* **Атрибуты:** единственная разрешённая «магия», контролируемая и явная.
* **Диагностика:** компилятор строгий, но вежливый.
* **Модули:** чистые, простые, не зоопарк из lib/bin/pkg.

---

# <a name="example"></a>5. Вкус Surge — пример на 40 строк

Ниже реалистичный фрагмент, объединяющий:

* async/await,
* task,
* каналы,
* владение,
* теги,
* контракты,
* extern<T>,
* структурированную конкурентность.

И при этом — всё читается понятно.

```sg

// Простой контракт – всё, что можно fetch'ить, должно реализовать fetch()
contract Fetchable {
    fn fetch(self: &Fetchable) -> Task<Success<string> | Error>;
}

// Тип данных + внешнее поведение
type Endpoint = { url: string };

extern<Endpoint> {
    async fn fetch(self: &Endpoint) -> Erring<string, Error> {
        let result = http_get(self.url).await();
        compare result {
            Success(text)  => return Success(text);
            err => return Error;
        }
    }
}

// Рабочий пайплайн с использованием каналов
async fn pipeline(endpoints: Endpoint[]) -> Success<string>[] {
    let ch = make_channel<Success<string> | Error>(10);

    // Продюсер: запускаем fetcher'ы
    async {
        for ep in endpoints {
            task async {
                let out = ep.fetch().await();
                send(&ch, out);
            };
        }
    };

    // Потребитель: собираем только Success-результаты
    let mut results: Success<string>[] = [];

    // Когда канал закрывается, recv() возвращает nothing
    while let Some(msg) = recv(&ch) {
        compare msg {
            Success(v)  => results.push(Success(v));
            finally => { /* игнорируем ошибки */ }
        }
    }

    return results;
}
```

Если этот пример выглядит читаемым —
в этом и весь смысл.
Он показывает перемещение владения (`task` принимает `ep` по значению),
заимствования (`recv(&ch)` явный)
и структурную типизацию (`contract Fetchable`) без украшательств.
Вы можете добавить `@drop` внутри цикла, если нужно завершить заимствование раньше, или пометить функцию `@failfast` для автоматической отмены задач при первой ошибке — но только когда вы об этом попросите.

---

# <a name="modules"></a>6. Модули и модель проекта

У Surge **одна** модульная система.

Нет:

* lib vs bin,
* packages vs crates vs assemblies,
* скрытых «магических» директорий.

Просто **модуль**.

Модули объявляются неявно по папке или явно с помощью:

```sg
pragma module::feature;
```

Модуль — это просто:

* именованное пространство имён,
* со своими файлами,
* импортирующее другие модули,
* производящее либо бинарник, либо библиотеку *в зависимости только от наличия @entrypoint*,
* опционально объединённое через несколько файлов с `pragma module;` в каждом файле, когда директория общая.

Вы можете переименовать модуль (`pragma module::bounded;`), объявить `pragma no_std;` для жизни без stdlib или пометить всю директорию как directive-модуль. Никаких неявных «магических папок»; всё прописано в начале файла.

Вот и всё.
Никакого безумия иерархий. Никаких догадок.

---

# <a name="toolchain"></a>7. Инструментарий Surge

### *(Прозрачность как ключевая фича)*

Surge поставляется с инструментом, который исповедует открытость:

```
surge diag        → запуск семантики, парсинга, проверки типов, диагностики
surge tokenize    → просмотр сырых токенов
surge parse       → показать полное AST
surge fix         → автоматически применить безопасные исправления
surge fmt         → форматирование кода
surge init        → создать базовый проект
surge build       → (заглушка) будущий пайплайн сборки VM/LLVM
```

Но звезда шоу:

## **diag + tracing**

Surge включает одну из самых прозрачных систем трассировки среди всех современных компиляторов:

* тайминг на уровне фаз,
* детальная трассировка для разрешения зависимостей,
* трассировка обхода AST на уровне отладки,
* поддержка Chrome Trace Viewer,
* кольцевая буферная трассировка для отладки зависаний,
* события heartbeat для локализации бесконечных циклов,
* вывод в ndjson для CI.


`--trace-level` варьируется от `phase` до `debug`, `--trace-mode` может быть потоковым, кольцевым или обоим, и heartbeat продолжает тикать даже если компилятор завис, чтобы вы знали, где он замёрз.
Диагностика включает предложения по исправлению там, где это безопасно, а директивный код живёт на настоящем Surge, так что тесты и бенчмарки — это тот же язык, который вы выпускаете.

Это не просто диагностика —
это *рентгеновское зрение* для понимания собственного кода.

Атрибуты вроде `@pure` проверяются; контракты конкурентности вроде `@guarded_by` проверяются; порядок блокировок и утечки задач диагностируются. Всё это выводится через `surge diag` с файлами трассировки, которые можно загрузить в Chrome Trace Viewer, когда захочется поспелеологировать.

Потому что язык должен помогать вам видеть больше, а не скрывать больше.

---

# <a name="attributes"></a>8. Контролируемая магия: система атрибутов

У Surge ровно **одно** место, где «магия» разрешена:
**атрибуты**.

Атрибуты — это маленькие подсказки компилятору, которые объявляют намерение:

* `@entrypoint`
* `@intrinsic`
* `@overload`
* `@pure`
* `@backend("gpu")`
* `@sealed`, `@packed`, `@align`, `@readonly`
* …и ещё несколько.

Но они никогда не скрывают поведение.
Они никогда не переписывают ваш код.
Они никогда не выполняют скрытых трансформаций.

Они просто маленькие, явные ручки настройки, чтобы помочь компилятору помочь вам.

---

# <a name="future"></a>9. Куда движется Surge

### *(Архитектура и видение)*

Surge **молод и быстро развивается**.
Не нестабилен — просто живой.

Вот краткая дорожная карта:

### **v1.x**

* полный фронтенд (AST, система типов, семантика),
* бэкенд выполнения на VM,
* система директив (тесты, бенчмарки, документация),
* AST-рефлексия для линтов и анализа,
* улучшенные примитивы конкурентности.

### **v1.5 → v2**

* настоящая многопоточность,
* LLVM-бэкенд для настоящей нативной производительности,
* система макросов (структурная генерация кода),
* улучшенные каналы и select,
* WASM-бэкенд.

Surge не пытается обещать луну с неба.
Surge пытается **расти вдумчиво**:
понятные шаги, понятная архитектура, никакого раздувания фич.

---

# <a name="documentation"></a>10. Документация

Вся подробная документация находится в:

```
/docs
    LANGUAGE.md
    DIRECTIVES.md
    ATTRIBUTES.md
    CONCURRENCY.md
    MODULES.md
    PRAGMA.md
    TRACING.md
    PARALLEL.md
```

Этот README — философия,
docs — это как-сделать и контракты.

Если вы хотите знать, как применяются правила владения, как ведёт себя `extern<T>`, как модули объединяются через файлы или как ограничены области async-задач, папка `/docs` — это каноническая, развивающаяся спецификация. Surge держит документацию близко к коду, чтобы философия и механика оставались синхронизированными.

---

# <a name="status"></a>11. Статус

**Surge активно разрабатывается.
Он молод, быстро развивается и открыт для исследования.**

Язык уже способен писать осмысленные программы,
и компилятор спроектирован с сильными гарантиями корректности.

Но путешествие только начинается —
и главное в этом путешествии то, что оно честное, открытое и не требует от вас быть кем-то другим.

Ожидайте шероховатостей, но также ожидайте, что компилятор признает их. Если чего-то не хватает, он так и скажет. Если что-то неправильно, он объяснит. Surge предпочитает быть прозрачным и слегка незаконченным, чем непрозрачным и «готовым».

Пишите код.
Будьте собой.
Surge прикроет вашу спину.

# <a name="thanks-to-go"></a> 12. **✨ Спасибо Go**

Surge в тихом, но огромном долгу перед **Go**, и это заслуживает быть сказанным явно.

Go научил меня, что язык программирования может быть **простым, не будучи примитивным**, чистым, не будучи стерильным, и мощным без акробатических трюков. Он показал, что опыт разработчика имеет такое же значение, как и сырая производительность — а иногда даже большее.

Surge не выглядел бы так, как выглядит, без влияния Go:

* **Горутины** вдохновили модель структурированной конкурентности.
  Не копированием, а пониманием ценности лёгких, честных задач.

* **Инструментарий Go** продемонстрировал, каким может быть ощущение от «один инструмент, много команд».
  Никакой фрагментированной экосистемы, никаких догадок, какой бинарник запускать.

* **Cobra** дала CLI Surge уверенность и эргономику, которые ему были нужны.
  Никаких самописных парсеров, никакой случайной сложности, никаких слоёв церемоний.

* **Структура проектов Go** научила нас, что файловая система может *быть* модульной системой,
  если язык достаточно дисциплинирован.

* **Фреймворк тестирования и бенчмарков** напомнил нам, что корректность и производительность
  должны жить прямо рядом с кодом, а не в далёком CI-пайплайне.

* **Инструменты фаззинга Go** помогли найти граничные случаи парсера задолго до того, как у языка появилось имя.

Это не про сравнение языков или объявление духовных преемников.
Это про благодарность.

Surge учится у Go так же, как учится у Rust и Python:
беря вещи, которые делают жизнь лучше,
и оставляя позади всё, что мешает ясности.

**Так что да — спасибо тебе, Go.
Ты помог сформировать Surge больше, чем сам знаешь.**
