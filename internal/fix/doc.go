// Package fix implements the "auto fix" pipeline that takes diagnostics
// emitted by the parser / analyzer, turns their suggested fixes into concrete
// text edits, и применяет эти изменения к исходным файлам.
//
// Общий рабочий цикл выглядит так:
//
//  1. Фазы компиляции добавляют в diag.Bag диагностические сообщения. Каждая
//     диагностика может содержать один или несколько предложенных fix.Fix с
//     текстовыми правками (Insert/Delete/Replace).
//  2. Команда (`surge fix ...`) собирает все диагностики, выбирает подходящие
//     правки и передаёт их в Apply().
//  3. Apply() материализует правки, сортирует их, следит за конфликтами,
//     корректирует смещения через cumulativeDelta и применяет текстовые правки
//     к реальным файлам (go fmt / запись на диск).
//
// Основные модули:
//
//   - builders.go: фабрики для создания Fix-объектов (InsertText, DeleteSpan,
//     ReplaceSpan). Они проставляют метаданные (вид фикса, безопасность и т.д.).
//   - engine.go: "движок" применения – сбор кандидатов, выбор режимов (once/all/id),
//     расчёт смещений, фактическое редактирование файлов и отчёты о применённых/пропущенных фикcах.
//   - builders_test.go / engine_test.go: тесты на корректность фабрик и движка.
//
// Важные детали:
//
//   - Fix.Materialize: некоторые фиксы создаются лениво (Thunk). Перед
//     применением движок материализует содержимое, чтобы получить готовые TextEdit.
//   - cumulativeDelta: когда применяют несколько правок в одном файле, предыдущие
//     изменения сдвигают координаты последующих. cumulativeDelta пересчитывает
//     смещение для каждого edit.
//   - Конфликты: перед применением очередного фикса движок проверяет пересечение
//     с уже применёнными правками (spansConflict). Если правка конфликтует или
//     не проходит guard/expect проверки, новая правка пропускается с reason.
//
// Это позволяет автофиксерам из любых фаз (parser, import checker, sema) вносить
// изменения в исходный файл безопасно и в устойчивом порядке.
package fix
