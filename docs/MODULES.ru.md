# Модули Surge и `pragma module`
[English](MODULES.md) | [Russian](MODULES.ru.md)

> **Статус:** Реализовано (многофайловые модули требуют `pragma module` / `pragma binary`)
> **Аудитория:** Пользователи языка Surge и авторы стандартной библиотеки
> **Цель:** Описывает концепцию модулей в Surge, правила построения многофайловых модулей, механизм `pragma module`, автоматическое определение имени модуля и когда прагма действительно необходима.

---

# 1. Что такое Модуль в Surge

Модуль — это **единица компиляции и переиспользования кода**, содержащая:

- объявленные типы, функции, константы, теги, контракты;
- собственное внутреннее пространство имен (имена внутри модуля не конфликтуют с внешними);
- четкие правила видимости (`pub`, `@hidden`, внутримодульные);
- собственный жизненный цикл во время компиляции (хеширование, кэширование, переиспользование).

Каждый модуль:

- имеет **уникальное имя**;
- экспортирует только `pub` элементы;
- может состоять из **одного файла** (по умолчанию) или **набора файлов в директории** (только с `pragma module` / `pragma binary`);
- может быть обычным модулем или исполняемым модулем (`binary`).

**Поведение по умолчанию (важно):**
- Если в директории **нет** `pragma module` / `pragma binary`, **каждый файл является собственным модулем**.
- Директория рассматривается как **многофайловый модуль** только тогда, когда *все* `.sg` файлы в этой директории объявляют `pragma module` или `pragma binary`.

---

# 2. Обычные и Бинарные Модули

Surge различает два вида модулей:

### **2.1. Обычный Модуль (`module`)**

Используется для библиотек, частей stdlib и любых неисполняемых единиц.

- Может иметь или не иметь `@entrypoint`.
- Если есть `@entrypoint`, вы можете запустить эту директорию как бинарник.
- Импортируется как обычный модуль.

### **2.2. Исполняемый Модуль (`binary`)**

Означает «модуль с точкой входа».

- Должен иметь **ровно одну** `@entrypoint`.
- Может импортироваться как обычный модуль.
- Может выполняться напрямую (`surge run foo/bar`).

Фактически, `binary` — это просто обычный модуль с дополнительным контрактом: «У меня есть единственная точка входа».

---

# 3. `pragma module`

`pragma module` — это **запись прагмы**, которая объявляет, что файл принадлежит **многофайловому модулю**, определенному всей директорией.

Пример:

```sg
pragma module
```

### Что делает `pragma module`:

* включает режим «один модуль на директорию»;
* объединяет все файлы в директории в единый модуль;
* включает общую таблицу символов (все файлы видят объявления друг друга);
* требует, чтобы эта прагма присутствовала и была согласована во всех файлах директории.

### Когда имя модуля устанавливается автоматически

Если `pragma module` используется **без имени**, то имя модуля = имя директории, при условии, что оно:

* является валидным идентификатором Surge (ASCII, без пробелов);
* не конфликтует с другими именами.

Пример:

Дерево директорий:

```
scripts/
   foo.sg
   util.sg
```

В `scripts/foo.sg`:

```sg
pragma module
```

→ имя модуля **scripts**

Импортируется как:

```sg
import scripts;
```

---

# 4. Явное имя модуля: `pragma module::name`

Если вам нужно другое имя или имя директории невалидно, вы можете указать имя явно:

```sg
pragma module::bounded
```

Теперь директория импортируется не по имени папки, а как `bounded`:

```
import bounded;
```

Даже если файл находится в `core/math/`, путь импорта будет:

```
import core/bounded;
```

### Правила согласованности:

* Если один из файлов в директории указывает имя:
  **все файлы должны указывать то же самое имя**.
* Если хотя бы один файл указывает имя явно — остальные тоже должны это сделать.

---

# 5. Когда `pragma module` обязательна

`pragma module` становится **обязательной**, если:

1. **Директория содержит более одного .sg файла**
   и эти файлы должны быть частью одного модуля.
2. **Вам нужно переопределить имя модуля** (через `::name`).
3. **Вам нужно указать, что модуль бинарный** (см. ниже).
4. Имя директории невалидно, поэтому требуется явное имя.

---

# 6. Когда `pragma module` не нужна

Вам не нужно писать `pragma module`, если:

* файл является **единственным** в своей директории;
* этот файл формирует модуль сам по себе;
* вам не нужно специальное поведение (`binary`, `no_std` и т.д.).

Пример:

```
math/
   trig.sg
```

`trig.sg` без прагмы:

→ модуль автоматически именуется по файлу, `trig`.

Импорт:

```sg
import math/trig;
```

---

# 7. Многофайловые модули

Если хотя бы один файл в директории имеет `pragma module` или `pragma binary`, то:

* **все файлы должны иметь одну из этих прагм**;
* имя модуля является общим для всей директории;
* все объявления верхнего уровня видимы между файлами, кроме помеченных `@hidden`.

Диагностика:
- `ProjMissingModulePragma`, если в некоторых файлах директории отсутствует прагма.
- `ProjInconsistentModuleName`, если файлы расходятся в явном `::name`.

### Пример структуры

```
core/vector/
   add.sg
   mul.sg
   impl.sg
```

В каждом файле:

```sg
pragma module
```

→ Создается модуль `core/vector`.

Все файлы видят:

```sg
fn internal_helper(...) { ... }
```

даже без `pub`.

Но если:

```sg
@hidden
fn __tmp() { ... }
```

то эта функция **видима только в текущем файле**.

---

# 8. Ошибки именования и предложения исправлений

### Пример ситуации

Файл:

```
foo/foo.sg
```

Содержит:

```sg
pragma module::bar;
```

Теперь модуль называется:

```
bar
```

Если программист пишет:

```sg
import foo/foo;
```

Компилятор должен:

* выдать ошибку: *"Модуль называется `bar`, а не `foo/foo`"*
* предложить авто-исправление: **изменить импорт на `foo/bar`**

Диагностика: `ProjWrongModuleNameInImport`.

---

# 9. `pragma binary`

Объявляет, что модуль является исполняемым:

```sg
pragma binary
```

Правила:

* модуль должен иметь ровно одну `@entrypoint`;
* файл точки входа может иметь любое имя (не обязательно `main.sg`);
* импорт `binary` работает так же, как и любой нормальный модуль.

### Явное имя:

```sg
pragma binary::run_app
```

Модуль теперь называется `run_app`.

---

# 10. Точки входа: `@entrypoint`

Точка входа может иметь любое имя:

```sg
@entrypoint
fn run() -> int { ... }
```

### Правила:

* в модуле `binary` должна быть **ровно одна** `@entrypoint`;
* перегрузки разрешены (`@overload`),
  потому что атрибут помечает конкретную функцию;
* бинарный модуль обязан иметь такую функцию;
* обычный модуль не обязан.

**Режимы:** `@entrypoint("argv")` и `@entrypoint("stdin")` поддерживаются; см. `docs/ATTRIBUTES.ru.md`.

---

# 11. Видимость объектов внутри модуля

В многофайловом модуле действуют следующие правила:

| Объявление | Видимость                       |
| ----------- | -------------------------------- |
| без `pub`  | видимо во всех файлах модуля  |
| `pub`          | экспортируется наружу                |
| `@hidden`      | видимо только в текущем файле |

`@hidden` имеет приоритет над `pub`:
`@hidden pub fn foo()` остается локальной для файла.

---

# 12. Импорты

Модули импортируются по пути:

```
import core/vector;
import foo/bar;
import ./local_module;
import ../parent_module;
```

Путь состоит из:

* сегментов директорий,
* финального сегмента — имени модуля (папка или `::name`).

Синтаксис импорта также поддерживает алиасинг и группы:

```
import core/math as m;
import core/math::{sin, cos};
import core/math::*;
```

См. `docs/LANGUAGE.ru.md` для полной грамматики.

Если модуль внутри директории был переименован — используйте новое имя.

**Порядок разрешения (упрощенно):**
1) `path.sg` (однофайловый модуль)
2) `path/` (модуль-директория с `pragma module`/`binary`)
3) сканирование явных имен для `pragma module::name` / `pragma binary::name`

---

# 13. Когда модуль должен быть Библиотекой или Бинарником

Используйте **бинарный модуль**, если:

* вам нужно его запускать (`surge run ...`);
* есть логическая точка входа;
* код должен "начать работать" при вызове.

Используйте **обычный модуль**, если:

* это библиотека или часть stdlib;
* `@entrypoint` отсутствует;
* никакая логика не должна выполняться автоматически.

---

# 14. Сводка

| Сценарий                         | Нужна `pragma module`?          | Примечание                                  |
| --------------------------------- | ------------------------------ | ------------------------------------- |
| Один файл в директории           | ❌ Нет                          | имя модуля = имя папки             |
| Несколько файлов, один модуль         | ✅ Да                         | каждый файл должен содержать прагму    |
| Нужно другое имя модуля      | ✅ Да (`::name`)              | имя папки игнорируется                |
| Нестандартное имя папки          | ✅ Да (`::name`)              | требуется явное имя                |
| Исполняемый модуль                 | ✅ `pragma binary`             | требует @entrypoint                  |
| Точка входа в обычном модуле   | ⚠️ Опционально                   | может быть запущен как бинарник                |
| Хотите локальные для файла объекты           | Используйте `@hidden`                  | прагма не влияет                |