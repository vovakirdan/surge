# Модель конкурентности Surge v1
[English](CONCURRENCY.md) | [Russian](CONCURRENCY.ru.md)

> **Статус:** VM использует однопоточный кооперативный планировщик. MT-исполнение, blocking pool и strict nonblocking описаны здесь как договор.
> **Область:** async/await, Task/TaskResult, spawn, каналы, отмена, таймауты, режимы MT executor, blocking { }, strict::nonblocking
> **Вне области:** data-parallel ключевые слова (`parallel map/reduce`), `signal`

---

## 1. Модель вкратце

Surge использует бесстековую модель задач с кооперативным планированием.
Исполнитель может быть одно- или многопоточным; это свойство рантайма и не меняет
абстракцию Task.

- Задачи — это **бесстековые конечные автоматы**, а не потоки ОС.
- Задача выполняется до тех пор, пока не достигнет точки приостановки (`await`, операции с каналами, `sleep`, `checkpoint`).
- `spawn` планирует задачу для конкурентного выполнения.
- Отмена **кооперативная** и наблюдается только в точках приостановки.
- MT-исполнение использует несколько рабочих потоков; одну задачу никогда не опрашивают (poll) одновременно разные worker'ы.
- OS-блокировка запрещена на рабочих потоках исполнителя; для OS-блокирующей работы используйте `blocking { ... }`.
- Если workers > 1 и есть несколько ядер, параллелизм возникает естественно (нет отдельной "MC" фичи).

Это сохраняет модель владения корректной между worker'ами без межпоточной проверки заимствований.

---

## 2. Термины: ожидание vs OS-блокировка

Surge различает ожидание на уровне задач и блокировку потока ОС:

- **Может ожидать**: операция, которая может приостановить задачу (park/unpark). В контексте Task ожидание означает парковку задачи, а worker продолжает выполнять другие задачи.
- **OS-блокировка**: операция, которая блокирует поток ОС (синхронный файловый ввод/вывод, системные мьютексы, внешние вызовы). OS-блокировка запрещена на worker-потоках исполнителя.
- **Парковка задачи**: исполнитель перестает опрашивать задачу до события пробуждения (канал готов, таймер сработал, задача завершилась).
- **Блокировка потока**: планировщик ОС останавливает worker-поток; другие задачи на этом worker'е не выполняются.
- **Асинхронное ожидание vs выполнение в blocking pool**: асинхронное ожидание паркует задачу в исполнителе; blocking pool выполняет код на выделенных потоках и возвращает `Task<T>`, который ожидается так же, как любая другая задача.

В core API термин "blocking" уже используется в значении "может ожидать"
(например, `Channel.send`/`recv`); это парковка задачи, а не OS-блокировка.

---

## 3. Task и TaskResult

Основные определения находятся в `core/intrinsics.sg`:

```sg
pub type Task<T> = { __opaque: int };

pub tag Cancelled();
pub type TaskResult<T> = Success(T) | Cancelled;

extern<Task<T>> {
    @intrinsic pub fn clone(self: &Task<T>) -> Task<T>;
    @intrinsic pub fn cancel(self: &Task<T>) -> nothing;
    @intrinsic pub fn await(self: own Task<T>) -> TaskResult<T>;
}
```

Ключевые моменты:

- `Task<T>` — непрозрачный handle бесстекового конечного автомата.
- `.await()` **поглощает** `own Task<T>` и возвращает `TaskResult<T>`.
- Используйте `handle.clone()`, если вам нужно несколько дескрипторов.
- `cancel()` работает по принципу best-effort; задачи замечают отмену в точках приостановки.

Пример:

```sg
let t = spawn fetch_user(42);
compare t.await() {
    Success(user) => print(user.name);
    Cancelled() => print("cancelled");
}
```

---

## 4. async функции и async блоки

```sg
async fn fetch_user(id: int) -> User {
    let raw = http_get("/users/" + id).await();
    return parse(raw);
}

let t: Task<User> = fetch_user(42);
```

- `async fn` возвращает `Task<T>` немедленно; она не запускается, пока не будет вызван `await` или `spawn`.
- `async { ... }` создает анонимную `Task<T>` из блока.
- `blocking { ... }` — это тоже блок, создающий Task (см. "Blocking scope").

`@failfast` разрешен на **async функциях** и **async блоках**:

```sg
@failfast
async fn pipeline() -> nothing {
    let a = spawn step_a();
    let b = spawn step_b();

    compare a.await() {
        Success(_) => nothing;
        Cancelled() => return;
    };
    compare b.await() {
        Success(_) => nothing;
        Cancelled() => return;
    };
}
```

Failfast означает: если дочерняя задача завершается с `Cancelled`, область видимости отменяет
оставшихся детей, и родитель возвращает `Cancelled`.

---

## 5. spawn

```sg
spawn expr
@local spawn expr
```

Правила:

- `expr` должно быть `Task<T>` (вызов async функции, async блок или `blocking { ... }`).
- `spawn` планирует задачу и возвращает дескриптор `Task<T>`.
- Только `own` значения могут пересекать границу задачи.
- `spawn` требует sendable-захватов; типы с `@nosend` отвергаются (`SemaNosendInSpawn`).
- `@local spawn` разрешает `@nosend` захваты, но возвращает локальный task handle (не sendable):
  его нельзя захватывать в `spawn`, отправлять через каналы или возвращать из функции.
- `spawn checkpoint()` вызывает предупреждение как бесполезный вызов (`SemaSpawnCheckpointUseless`).

Пример:

```sg
async fn work(x: int) -> int { return x * 2; }

let t1 = spawn work(10);
let t2 = spawn work(20);

compare t1.await() {
    Success(v) => print("t1=" + (v to string));
    Cancelled() => print("t1 cancelled");
}
compare t2.await() {
    Success(v) => print("t2=" + (v to string));
    Cancelled() => print("t2 cancelled");
}
```

Инварианты MT-ready модели:

- `spawn` требует Sendable захваты; `@local spawn` разрешает `@nosend`.
- Local task handle нельзя переносить в sendable-контекст (capture в `spawn`, return, send по каналу).
- `Task<T>` — SuspendSafe через `await` (контейнеры SuspendSafe, если элементы SuspendSafe).
- Контейнеры задач нужно дренировать (`pop` + `await`) до выхода из scope.

---

## 6. await

`.await()` — это **вызов метода**, возвращающий `TaskResult<T>`:

```sg
compare fetch_user(42).await() {
    Success(user) => print("ok");
    Cancelled() => print("cancelled");
}
```

Правила:

- Разрешено внутри `async` функций/блоков и `@entrypoint` функций.
- Запрещено в простых синхронных функциях (`SemaIntrinsicBadContext`).
- `await` внутри циклов в настоящее время **не поддерживается** (MIR lowering отвергает это).

---

## 7. Структурированная конкурентность (Scopes)

Surge принуждает к структурированной конкурентности на этапе семантического анализа (sema):

- Созданные задачи должны быть **ожидаемы (awaited) или возвращены**.
- Утечка задачи из области видимости вызывает ошибки:
  - `SemaTaskNotAwaited` (3107)
  - `SemaTaskEscapesScope` (3108)
  - `SemaTaskLeakInAsync` (3109)
  - `SemaTaskLifetimeError` (3110)

В рантайме каждая async функция/блок создает область видимости (scope). При выходе из области
рантайм джойнит (joins) всех детей перед завершением. Возврат `Task<T>` передает
ответственность вызывающему. Это относится к задачам, созданным через `async { ... }`,
async функции и `blocking { ... }`.

---

## 8. Отмена, таймауты и уступка (yielding)

Intrinsics:

```sg
@intrinsic pub fn checkpoint() -> Task<nothing>;
@intrinsic pub fn sleep(ms: uint) -> Task<nothing>;
@intrinsic pub fn timeout<T>(t: Task<T>, ms: uint) -> TaskResult<T>;
```

Заметки:

- `checkpoint().await()` уступает управление планировщику и проверяет отмену.
- `sleep(ms).await()` приостанавливает выполнение на `ms` (виртуальное время по умолчанию).
- `timeout(t, ms)` ждет до `ms` и возвращает `Success` или `Cancelled`.
  Он отменяет цель по истечении времени.
- Таймеры по умолчанию работают в виртуальном времени. Реальное время
  включается через `surge run --real-time`.
- Отмена кооперативна и не прерывает OS-блокирующие вызовы (см. "Blocking scope").

Пример:

```sg
let t = spawn slow_call();
compare timeout(t, 500:uint) {
    Success(v) => print("done " + (v to string));
    Cancelled() => print("timed out");
}
```

### Select и Race

`select` ждёт несколько awaitable операций (Task `.await()`, канальные
`recv`/`send`, `sleep`, `timeout`) и возвращает результат выбранной ветки.

Правила:

- Армы проверяются сверху вниз; первый готовый побеждает (детерминированный tie-break).
- Если есть `default` и ничего не готово, выполняется `default` без блокировки.
- Без `default` задача паркуется до готовности одной из веток.
- `select` не отменяет проигравшие ветки.

`race` имеет тот же синтаксис и правила выбора, но **отменяет проигравшие Task-ветки**
(не-тасковые ветки не отменяются).

Пример:

```sg
let v = select {
    ch.recv() => 1;
    sleep(10).await() => 2;
    default => 0;
};

let r = race {
    t1.await() => 1;
    t2.await() => 2;
};
```

---

## 9. Каналы (Channels)

`Channel<T>` — это типизированный FIFO дескриптор (копируемый):

```sg
let ch = make_channel::<int>(16);
ch.send(42);
let v = ch.recv();
```

API (core intrinsics):

- `make_channel<T>(capacity: uint) -> own Channel<T>`
- `Channel<T>::new(capacity: uint) -> own Channel<T>`
- `send(self: &Channel<T>, value: own T) -> nothing` (может ожидать)
- `recv(self: &Channel<T>) -> Option<T>` (может ожидать)
- `try_send(self: &Channel<T>, value: own T) -> bool`
- `try_recv(self: &Channel<T>) -> Option<T>`
- `close(self: &Channel<T>) -> nothing` (может ожидать)

Заметки:

- `send`/`recv`/`close` являются точками приостановки в async коде (парковка задачи).
- `recv` возвращает `nothing`, когда канал закрыт и пуст.
- Отправка в закрытый канал — ошибка времени выполнения.
- Значения с `@nosend` нельзя передавать через каналы (`SemaChannelNosendValue`).

---

## 10. Модель исполнителя и планирование

### 10.1 Режимы исполнителя (свойство рантайма)

- Исполнитель может работать с одним worker'ом или несколькими worker'ами.
- MT — это конфигурация рантайма; абстракция Task и семантика языка не меняются.
- Если workers > 1 и есть несколько ядер, задачи могут выполняться параллельно.

### 10.2 Базовые MT-инварианты

- Задача никогда не опрашивается одновременно несколькими worker'ами.
- Рабочие потоки исполнителя не должны выполнять OS-блокирующие операции.
- Точки приостановки паркуют задачу до события пробуждения, освобождая worker.

### 10.3 Режимы планирования

- **Parallel mode:** несколько worker'ов, недетерминированные интерливинги;
  порядок определяется только синхронизацией программы.
- **Seeded (reproducible) mode:** решения планировщика детерминированы при
  одинаковом seed и одинаковом порядке внешних событий. Это best-effort.
  Ограничения включают порядок завершения внешнего I/O, системное время,
  планирование потоков blocking pool, FFI и любые другие недетерминированные источники.
- **VM/testing mode:** может выбирать одно-worker или seeded планирование.

### 10.4 Справедливость и CPU-bound работа

Справедливость гарантируется для задач **Ready** в одно-worker режиме при
кооперативном планировании:

- **F1 (round-robin для Ready):** при конечном множестве готовых задач каждая
  Ready-задача будет снова опрошена не позднее чем через `N-1` опросов других
  Ready-задач (где `N` — текущий размер ready-набора).
- **F2 (один poll за шаг):** каждый шаг планировщика выполняет ровно один poll;
  задача, которая `Yielded`, возвращается в конец ready-очереди, а `Parked` не
  переочередляется.
- **F3 (детерминизм):** в обычном режиме порядок FIFO по task/wake; в seeded-режиме
  выбор детерминирован при фиксированном seed и порядке событий.

В parallel mode нет глобального FIFO порядка, и справедливость между worker'ами
best-effort.

Плотные CPU-циклы без точек приостановки могут морить другие задачи голодом.
Рантайм **не** вставляет yield или принудительную преемпцию по умолчанию.
Используйте `checkpoint().await()` для кооперации. Проверки safepoint /
преемпция могут появиться только как явный опциональный режим в будущем и не
гарантированы без включения.

---

## 11. Blocking scope (`blocking { ... }`)

`blocking { ... }` — это явный block-expression для OS-блокирующей работы. Он
возвращает `Task<T>` и выполняется в выделенном blocking pool, а не на worker'ах исполнителя.

Правила:

- `blocking { ... }` выполняется вне рабочих потоков исполнителя.
- Он возвращает `Task<T>` и ожидается через `.await()` (или планируется через `spawn`).
- Как и `async { ... }`, он не выполняется, пока не будет запланирован или awaited.
- Отмена best-effort; OS-блокирующие вызовы могут быть непредотвратимыми.
- Чрезмерное использование `blocking { ... }` — риск для производительности
  (насыщение потоков, накладные расходы планирования и задержки).

Пример:

```sg
let t = blocking {
    return read_file(path);
};

compare t.await() {
    Success(data) => print(data);
    Cancelled() => print("cancelled");
}
```

---

## 12. Строгий nonblocking режим (`pragma strict::nonblocking`)

`pragma strict::nonblocking` — это opt-in правило строгости на уровне файла.
В этом режиме код в task-контексте не должен выполнять OS-блокирующие операции
без `blocking { ... }`.

Проверки опираются на существующие контракты:

- `@nonblocking` помечает функцию как неблокирующую; она не может вызывать операции "может ожидать".
- `@waits_on("field")` помечает функцию как потенциально ожидающую `Condition`
  или `Semaphore`.
- Компилятор считает следующую группу методов "blocking/may-wait":
  `Mutex.lock`, `RwLock.read_lock`, `RwLock.write_lock`, `Condition.wait`,
  `Semaphore.acquire`, `Channel.send`, `Channel.recv`, `Channel.close`.

При `strict::nonblocking` компилятор применяет эти проверки к task-контексту и
его вызовам. Правило намеренно консервативное: любой вызов, который известно
(или явно заявлено), что **может ожидать**, трактуется как потенциальная
OS-блокировка и запрещается в task-контексте.

Без этого pragma проверки `@nonblocking` действуют только для функций, явно
помеченных `@nonblocking`.

Почему это консервативно:

- Факт OS-блокировки может зависеть от состояния рантайма, ОС или внешних ресурсов.
- Компилятор не может доказать неблокирующее поведение в общем случае.
- Поэтому strict-режим полагается на явные контракты (`@nonblocking`, `@waits_on`)
  и консервативные проверки известных примитивов ожидания.

---

## 13. Гарантии и негарантии

Гарантии (контракт):

- Задача никогда не опрашивается одновременно несколькими worker'ами.
- Структурированная конкурентность: задачи должны быть awaited или возвращены; scope владеет задачами.
- Точки приостановки паркуют задачи вместо блокировки worker'ов исполнителя.
- Отмена кооперативна и наблюдается в точках приостановки.
- OS-блокировка запрещена на worker'ах исполнителя; OS-блокирующая работа должна быть изолирована в `blocking { ... }`.

Негарантии (явно не обещается):

- Детерминизм в parallel mode (порядок планирования недетерминирован).
- Глобальный FIFO порядок или справедливость между несколькими worker'ами.
- Автоматическая преемпция или вставка yield в CPU-bound циклах.
- Прерывание OS-блокирующих вызовов (отмена best-effort).
- Полная воспроизводимость в seeded режиме при отличающихся внешних событиях.

---

## 14. Ограничения (v1)

- Бэкенд VM сегодня одно-worker; MT-исполнение — опция рантайма для других бэкендов.
- `parallel map/reduce` и `signal` остаются зарезервированными ключевыми словами (не поддерживаются).
- `await` внутри циклов не поддерживается (MIR lowering отвергает это).

См. `docs/PARALLEL.ru.md` для статуса параллельных функций.

---

## 15. Заметки по реализации / открытые наблюдения (ненормативные)

- Термин "blocking" уже используется в core API в значении "может ожидать"
  (парковка задачи), что может путать с OS-блокировкой, несмотря на различие.
- `@nonblocking` сейчас считает операции каналов (`send`/`recv`/`close`) блокирующими,
  поэтому `strict::nonblocking` вероятно запретит распространенные async паттерны,
  пока это различие не станет более явным.
- Отсутствие `await` в циклах делает неудобным выражение периодических
  `checkpoint().await()` в долгих CPU-циклах.
- Seeded планирование зависит от порядка внешних событий; границы воспроизводимости
  могут требовать более явных указаний в тестовой инфраструктуре.
