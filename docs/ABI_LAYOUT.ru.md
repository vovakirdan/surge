# ABI Layout (v1) — x86_64-linux-gnu
[English](ABI_LAYOUT.md) | [Russian](ABI_LAYOUT.ru.md)

Этот документ определяет **контракт размещения (layout) ABI v1** для Surge на поддерживаемой
целевой платформе (runtime target):

- Target triple: `x86_64-linux-gnu`
- Размер указателя / выравнивание: `8` / `8` байт

Виртуальная машина (VM) может хранить значения иначе внутри, но **запросы размещения (layout queries)** должны
следовать этим правилам:

- `size_of<T>()` возвращает размер ABI.
- `align_of<T>()` возвращает выравнивание ABI.

Единственным источником истины является `internal/layout` (`LayoutEngine`).

---

## 1. Соглашения

- **Handle**: значение размером с указатель, ссылающееся на объект в куче.
- Числовые значения Handle **не являются стабильными в ABI** и не должны появляться в golden-тестах.
- `own` и псевдонимы типов (type aliases) **не влияют на размещение** (канонизируются перед расчетом layout).

---

## 2. Скаляры

### 2.1. Базовые скаляры

- `bool`: размер `1`, выравнивание `1`
- `unit`: размер `0`, выравнивание `1`
- `nothing`: размер `0`, выравнивание `1`

### 2.2. Числовые типы фиксированной ширины

- `int8/uint8`: `1/1`
- `int16/uint16`: `2/2`
- `int32/uint32`: `4/4`
- `int64/uint64`: `8/8`
- `float16`: `2/2`
- `float32`: `4/4`
- `float64`: `8/8`

### 2.3. Динамические числовые типы (контракт v1)

`int`, `uint`, `float` имеют **размер handle** для запросов размещения ABI:

- `int`: `8/8`
- `uint`: `8/8`
- `float`: `8/8`

---

## 3. Указатели и Ссылки

- Сырые указатели (`*T`): `8/8`
- Ссылки (`&T`, `&mut T`): `8/8`
- Указатели на функции: `8/8`

---

## 4. Перечисления (Enums)

- Если у enum есть явный базовый тип, используется layout базового типа.
- В противном случае, v1 использует по умолчанию `uint32` (`4/4`).

---

## 5. Значения на основе Handle (Handle-Backed Values)

Следующие поверхностные типы имеют размер handle в ABI v1:

- `string`
- `Array<T>` / `T[]` (динамические)
- `Range<T>`

Их размер/выравнивание в ABI составляет `8/8` на этой цели.

Другие типы стандартной библиотеки, основанные на handle, определены как непрозрачные структуры в
`core/intrinsics.sg` и следуют обычным правилам размещения структур (например, `Task<T>`,
`Channel<T>`, `Mutex`, `RwLock`, `Condition`, `Semaphore`).

---

## 6. ABI BytesView

`BytesView` определен в `core/intrinsics.sg` и имеет **стабильный порядок полей**:

1. `owner: string`
2. `ptr: *byte`
3. `len: uint`

Layout (x86_64): размер `24`, выравнивание `8`.

Семантика:

- `owner` поддерживает жизнь байтов.
- `ptr` указывает на непрерывные байты UTF-8.
- `len == rt_string_len_bytes(&owner)`.

Тесты:

- `testdata/golden/abi/abi_string_bytesview.sg`
- `internal/vm/vm_abi_layout_test.go`

---

## 7. Массивы

### 7.1. Динамические массивы (`Array<T>` / `T[]`)

- Размер/выравнивание ABI — `8/8` (handle).
- Внутреннее размещение **специфично для VM** и не является частью ABI.

Заметки VM (не стабильно в ABI):

- Массивы — это объекты кучи с хранилищем элементов.
- Срезы (slicing) возвращают **объект-представление (view object)**, который держит сильную ссылку на базу.
- Представления **не изменяемы по размеру**; `push/pop/reserve` вызывают панику во время выполнения.

### 7.2. Фиксированные массивы (`ArrayFixed<T, N>` / `T[N]`)

Фиксированные массивы хранятся inline (внутри структуры):

- `align = align_of(T)`
- `stride = roundUp(size_of(T), align_of(T))`
- `size = stride * N`

Индексация использует `base + i * stride`.

Тесты:

- `testdata/golden/abi/abi_core_sizes.sg`
- `internal/vm/vm_abi_layout_test.go`

---

## 8. Кортежи (Tuples)

Кортежи используют те же правила размещения, что и структуры (упорядоченные поля):

1. Каждый элемент начинается со смещения, выровненного по его выравниванию.
2. Выравнивание кортежа — это максимальное выравнивание элемента.
3. Общий размер округляется вверх до выравнивания кортежа.

---

## 9. Размеченные объединения (Tagged Unions - tag/union)

Размеченные объединения (`tag` + union типы) используют фиксированный layout v1:

- Тег — это `uint32` (`size=4`, `align=4`).
- Payload (полезная нагрузка) — это член с **максимальным** размером/выравниванием.
- `payload_offset = roundUp(tag_size, payload_align)`.
- `overall_align = max(tag_align, payload_align)`.
- `size = roundUp(payload_offset + payload_size, overall_align)`.

Если у тега несколько значений payload, payload размещается как кортеж.

Тесты:

- `internal/vm/vm_abi_layout_test.go` (размер/выравнивание тега, смещение payload)

---

## 10. Структуры и Смещения полей

Поля размещаются в порядке объявления:

1. Каждое поле начинается со следующего смещения, выровненного по выравниванию поля.
2. Выравнивание структуры — это максимальное выравнивание поля.
3. Размер структуры округляется вверх до выравнивания структуры.

### 10.1. Атрибуты размещения (Layout Attributes)

В v1 только эти атрибуты влияют на размещение:

- `@packed` (тип)
- `@align(N)` (тип или поле)

#### `@packed` на типе структуры

- Нет padding (отступов) между полями; поля упакованы последовательно.
- Выравнивание структуры — `1`.
- Нет хвостового padding.

#### `@align(N)` на типе или поле

- Выравнивание поля — `max(field_align, N)`.
- Выравнивание структуры — `max(все field aligns, type_align_override)`.
- Размер структуры округляется вверх до финального выравнивания.

`@packed` и `@align` **взаимоисключающие** (ошибка времени компиляции).

---

## 11. String ABI

### 11.1. Handle и доступ по указателю

- `string` — это handle (размер `8`, выравнивание `8`).
- `rt_string_ptr(&s)` возвращает указатель на непрерывные байты UTF-8.
- VM может материализовать (сплющить) rope-строки по требованию.

### 11.2. Длина

- `rt_string_len(&s)` возвращает **количество кодовых точек Unicode**.
- `rt_string_len_bytes(&s)` возвращает длину в байтах UTF-8.

### 11.3. Нормализация

Конструкторы строк нормализуют ввод в NFC:

- `rt_string_from_bytes`
- `rt_string_from_utf16`

Другие операции со строками сохраняют существующую нормализацию.

Тесты:

- `testdata/golden/abi/abi_string_bytesview.sg`
- `internal/vm/vm_abi_layout_test.go`

---

## 12. Range ABI

`Range<T>` — это **непрозрачный handle**. Runtime использует внутренние состояния для
литералов диапазонов и итерации по массивам, но эти внутренние layouts **не стабильны
в ABI**. Только `size_of` / `align_of` стабильны.

---

## 13. Заметки и Ссылки

- Движок размещения (layout engine): `internal/layout`
- Тесты размещения VM: `internal/vm/vm_abi_layout_test.go`
- Goldens: `testdata/golden/abi/`