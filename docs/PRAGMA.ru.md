# Pragma в Surge (актуальное состояние)
[English](PRAGMA.md) | [Russian](PRAGMA.ru.md)

`pragma` — это декларация свойств **файла/модуля**, которую читает фронтенд. Она влияет на сборку и правила импорта, но не является обычным узлом AST выражений или операторов.

## 1) Базовые правила

- `pragma` должна быть **первой значимой строкой** файла.
- **Только одна** `pragma` на файл.
- Формат: список идентификаторов через запятую.
- Нарушение позиции фиксируется диагностикой `SynPragmaPosition`.

```sg
pragma module, no_std
```

Каждый элемент — это **pragma-ключ** (identifier). Некоторые ключи поддерживают **явное имя** в форме `name::value`.

```sg
pragma module::bounded
```

Неизвестные ключи **парсятся**, но пока **игнорируются** (зарезервированы под будущее).

---

## 2) Реализованные pragma

### 2.1 `pragma module` и `pragma binary`

**Назначение:** объявить многофайловый модуль в пределах директории.

- Если **хотя бы один** файл в директории содержит `pragma module` или `pragma binary`, **все** `.sg` файлы в этой директории обязаны иметь такую же `pragma`.
- `module` и `binary` нельзя смешивать в одной директории.
- Имя модуля:
  - по умолчанию = имя директории;
  - можно переопределить через `::name`.
- `binary` требует **ровно один** `@entrypoint` в модуле.

```sg
// в каждом файле директории
pragma module;
```

```sg
// явное имя модуля
pragma module::bounded;
```

```sg
// исполняемый модуль
pragma binary::run_app;
```

**Диагностики (project-уровень):**
- `ProjMissingModulePragma` — если часть файлов без `pragma`.
- `ProjInconsistentModuleName` — если имена не совпадают.

---

### 2.2 `pragma directive`

Помечает модуль как **директивный**, чтобы его можно было использовать в `///`-директивах.

- В режимах `--directives=collect|gen|run` компилятор проверяет, что namespace директивы соответствует импортированному модулю с `pragma directive`.
- Без этой pragma директивы использовать модуль нельзя.

```sg
pragma directive;

pub fn eq<T>(a: T, b: T) -> bool { ... }
```

---

### 2.3 `pragma no_std`

Переводит модуль в режим без стандартной библиотеки:

- импорты `stdlib/...` переписываются в `core/...`;
- выдаётся ошибка `SemaNoStdlib` с подсказкой на правильный импорт;
- значение `no_std` должно быть **одинаковым** во всех файлах многофайлового модуля.
  Несовпадение даёт `ProjInconsistentNoStd`.

```sg
pragma module, no_std
```

---

### 2.4 `pragma strict` и `pragma unsafe`

Эти ключи **парсятся**, но **не применяются** в текущей версии.

- `strict` — задел под строгий режим (warnings → errors, жесткие правила стиля).
- `unsafe` — задел под будущие `unsafe {}` блоки.

---

## 3) Зарезервированные pragma (пока без поведения)

Следующие идеи поддерживаются как **зарезервированные ключи**, но ещё не реализованы:

- `pragma feature(...)`
- `pragma build ...`
- `pragma version ...`
- `pragma export(...)`
- `pragma cache ...`

Если нужен такой ключ — он будет принят синтаксически, но не повлияет на компиляцию.

---

## 4) Примеры

```sg
// обычный многофайловый модуль
pragma module
```

```sg
// бинарный модуль с entrypoint
pragma binary
@entrypoint
fn main() -> int { return 0; }
```

```sg
// модуль без stdlib
pragma module, no_std
import core/format;
```
