tag Start();
tag Tick(int);
tag Fail(string);
tag Finish();

type Event = Start() | Tick(int) | Fail(string) | Finish();

tag Idle();
tag Running(int);
tag Err(string);
tag Done(int);

type State = Idle() | Running(int) | Err(string) | Done(int);

fn step(state: State, event: Event) -> State {
    return compare state {
        Idle() => compare event {
            Start() => { let out: State = Running(0); return out; };
            finally => { let out: State = Idle(); return out; };
        };
        Running(downloaded) => compare event {
            Tick(bytes) => { let out: State = Running(downloaded + bytes); return out; };
            Fail(msg) => { let out: State = Err(msg); return out; };
            Finish() => { let out: State = Done(downloaded); return out; };
            finally => { let out: State = Running(downloaded); return out; };
        };
        Err(msg) => compare event {
            Fail(err_msg) => { let out: State = Err(err_msg); return out; };
            finally => { let out: State = Err(msg); return out; };
        };
        Done(total) => compare event {
            Finish() => { let out: State = Done(total); return out; };
            finally => { let out: State = Done(total); return out; };
        };
    };
}

@entrypoint
fn main() {
    let s: State = Idle();

    let e0: Event = Start();
    s = step(s, e0);
    let e1: Event = Tick(100);
    s = step(s, e1);
    let e2: Event = Tick(50);
    s = step(s, e2);
    let e3: Event = Finish();
    s = step(s, e3);

    let result = compare s {
        Idle() => "idle";
        Running(downloaded) => "running " + (downloaded to string);
        Err(msg) => "error " + msg;
        Done(total) => "done " + (total to string);
    };
    print(result);
}
