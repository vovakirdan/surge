// Операторы и выражения
fn test_arithmetic_operators() -> int {
    // Арифметические операторы
    let a: int = 10;
    let b: int = 3;

    let sum: int = a + b;        // 13
    let diff: int = a - b;       // 7
    let product: int = a * b;    // 30
    let quotient: int = a / b;   // 3
    let remainder: int = a % b;  // 1

    // Унарные операторы
    let negative: int = -a;      // -10
    let positive: int = +a;      // 10

    return sum + diff + product + quotient + remainder + negative + positive;
}

fn test_comparison_operators() -> bool {
    let x: int = 5;
    let y: int = 10;

    // Операторы сравнения
    let equal: bool = x == y;           // false
    let not_equal: bool = x != y;       // true
    let less: bool = x < y;             // true
    let less_equal: bool = x <= y;      // true
    let greater: bool = x > y;          // false
    let greater_equal: bool = x >= y;   // false

    return equal || not_equal || less || less_equal || greater || greater_equal;
}

fn test_logical_operators() -> bool {
    let a: bool = true;
    let b: bool = false;

    // Логические операторы
    let and_result: bool = a && b;      // false
    let or_result: bool = a || b;       // true
    let not_a: bool = !a;               // false
    let not_b: bool = !b;               // true

    return and_result || or_result || not_a || not_b;
}

fn test_bitwise_operators() -> int {
    let x: int = 12;  // 1100 в двоичной
    let y: int = 10;  // 1010 в двоичной

    // Битовые операторы
    let and_bits: int = x & y;          // 1000 = 8
    let or_bits: int = x | y;           // 1110 = 14
    let xor_bits: int = x ^ y;          // 0110 = 6

    // Сдвиги
    let left_shift: int = x << 2;       // 110000 = 48
    let right_shift: int = x >> 2;      // 11 = 3

    return and_bits + or_bits + xor_bits + left_shift + right_shift;
}

fn test_assignment_operators() -> int {
    let mut x: int = 10;

    // Составные операторы присваивания
    x += 5;     // x = x + 5, теперь x = 15
    x -= 3;     // x = x - 3, теперь x = 12
    x *= 2;     // x = x * 2, теперь x = 24
    x /= 4;     // x = x / 4, теперь x = 6
    x %= 4;     // x = x % 4, теперь x = 2

    let mut y: int = 8;
    y &= 12;    // y = y & 12
    y |= 3;     // y = y | 3
    y ^= 5;     // y = y ^ 5
    y <<= 1;    // y = y << 1
    y >>= 2;    // y = y >> 2

    return x + y;
}

fn test_increment_decrement() -> int {
    let mut counter: int = 5;

    // Используем составные операторы вместо ++/--
    counter += 1;   // 6
    let after_inc: int = counter;
    counter -= 1;   // 5
    let after_dec: int = counter;

    return after_inc + after_dec + counter; // 6 + 5 + 5 = 16
}

fn test_ternary_operator() -> string {
    let condition: bool = true;
    let x: int = 10;

    // Тернарный оператор
    let result: string = condition ? "true case" : "false case";
    let number_result: int = x > 5 ? x * 2 : x / 2;

    // Вложенные тернарные операторы
    let nested: string = x > 15 ? "large" : (x > 5 ? "medium" : "small");

    let summary: string = result + " " + nested;
    let total: int = number_result + x;

    if (total > 0) {
        return summary;
    }

    return result;
}

fn test_null_coalescing() -> string {
    let maybe_string: Option<string> = Some("hello");
    let empty_string: Option<string> = nothing;

    // Null coalescing operator
    let result1: string = maybe_string ?? "default";
    let result2: string = empty_string ?? "default";

    return result1 + result2;
}

fn test_operator_precedence() -> int {
    // Тестирование приоритета операторов
    let result1: int = 2 + 3 * 4;           // 14, не 20
    let result2: int = (2 + 3) * 4;         // 20
    let result3: int = 2 * 3 + 4 * 5;       // 26
    let result4: bool = true || false && false; // true

    if (result4) {
        return result1 + result2 + result3;
    }

    return result1;
}
