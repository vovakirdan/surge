pragma module, no_std;

pub type byte = uint8;

@intrinsic fn rt_alloc(size: uint, align: uint) -> *byte;
@intrinsic fn rt_free(ptr: *byte, size: uint, align: uint) -> nothing;
@intrinsic fn rt_realloc(ptr: *byte, old_size: uint, new_size: uint, align: uint) -> *byte;
@intrinsic fn rt_memcpy(dst: *byte, src: *byte, n: uint) -> nothing;
@intrinsic fn rt_memmove(dst: *byte, src: *byte, n: uint) -> nothing;

// I/O primitives
@intrinsic fn rt_write_stdout(ptr: *byte, length: uint) -> uint;
@intrinsic fn rt_read_stdin(buf: *byte, max_len: uint) -> uint;

// String access intrinsics
@intrinsic fn rt_string_ptr(s: &string) -> *byte;
// Returns Unicode code point length (not bytes).
@intrinsic fn rt_string_len(s: &string) -> uint;
@intrinsic fn rt_string_len_bytes(s: &string) -> uint;
@intrinsic fn rt_string_from_bytes(ptr: *byte, length: uint) -> string;
@intrinsic fn rt_string_from_utf16(ptr: *uint16, length: uint) -> string;
@intrinsic fn rt_string_bytes_view(s: &string) -> BytesView;
// Test-only hook: materialize flat UTF-8 bytes for a rope/slice string.
@intrinsic fn rt_string_force_flatten(s: &string) -> nothing;

// Array access intrinsics
@intrinsic fn rt_array_reserve<T>(a: &mut Array<T>, new_cap: uint) -> nothing;
@intrinsic fn rt_array_push<T>(a: &mut Array<T>, value: T) -> nothing;
@intrinsic fn rt_array_pop<T>(a: &mut Array<T>) -> Option<T>;

// Higher-level I/O
@intrinsic
pub fn readline() -> string;

@intrinsic
pub type Range<T> = {
    __state: *byte,
};

// Range literal constructors (descriptor-only, not iterator ranges).
@intrinsic pub fn rt_range_int_new(start: int, end: int, inclusive: bool) -> Range<int>;
@intrinsic pub fn rt_range_int_from_start(start: int, inclusive: bool) -> Range<int>;
@intrinsic pub fn rt_range_int_to_end(end: int, inclusive: bool) -> Range<int>;
@intrinsic pub fn rt_range_int_full(inclusive: bool) -> Range<int>;

extern<Range<T>> {
    @intrinsic pub fn next(self: &mut Range<T>) -> Option<T>;
}

pub type HeapStats = {
    alloc_count: uint,
    free_count: uint,
    live_blocks: uint,
    live_bytes: uint,
    rc_increments: uint,
    rc_decrements: uint,
};

// Heap stats are deterministic within a run.
// alloc/free include heap objects and raw memory blocks.
// live_bytes sums per-object payload bytes (strings use UTF-8 byte length; arrays use len*elem_size;
// views count 0; structs/tags/ranges use layout size; big numbers use limb bytes; raw uses alloc size).
@intrinsic pub fn rt_heap_stats() -> HeapStats;
// Deterministic heap summary with no addresses or allocation IDs.
@intrinsic pub fn rt_heap_dump() -> string;

pub type Task<T> = {
    __opaque: int,
};

pub tag Cancelled();
pub type TaskResult<T> = Success(T) | Cancelled;

extern<Task<T>> {
    @intrinsic pub fn clone(self: &Task<T>) -> Task<T>;
    @intrinsic pub fn cancel(self: &Task<T>) -> nothing;
    @intrinsic pub fn await(self: own Task<T>) -> TaskResult<T>;
}

// Cooperative yield point for CPU-bound work
// Allows scheduler to check for cancellation and yield to other tasks
@intrinsic
pub fn checkpoint() -> Task<nothing>;

// Typed channel for inter-task communication
@intrinsic
pub type Channel<T> = {
    __opaque: *byte,
};

extern<Channel<T>> {
    // Create a new channel with given capacity (0 = unbuffered)
    @intrinsic pub fn new(capacity: uint) -> own Channel<T>;
    // Blocking send - suspends until channel has capacity
    @intrinsic pub fn send(self: &Channel<T>, value: own T) -> nothing;
    // Blocking receive - suspends until value available, returns Nothing if closed
    @intrinsic pub fn recv(self: &Channel<T>) -> Option<T>;
    // Non-blocking send - returns false if channel full
    @intrinsic pub fn try_send(self: &Channel<T>, value: own T) -> bool;
    // Non-blocking receive - returns Nothing if channel empty
    @intrinsic pub fn try_recv(self: &Channel<T>) -> Option<T>;
    // Close the channel - no more values can be sent
    @intrinsic pub fn close(self: &Channel<T>) -> nothing;
}

@intrinsic
fn make_channel<T>(capacity: uint) -> own Channel<T>;

pub contract Bounded<T> {
    fn __min_value() -> T;
    fn __max_value() -> T;
}

pub contract HasLength<T> {
    fn __len(self: &T) -> uint;
}

pub contract Printable<T> {
    fn __to(self: &T, target: string) -> string;
}

extern<int> {
    @intrinsic fn __add(self: int, other: int) -> int;
    @intrinsic fn __sub(self: int, other: int) -> int;
    @intrinsic fn __mul(self: int, other: int) -> int;
    @intrinsic fn __div(self: int, other: int) -> int;
    @intrinsic fn __mod(self: int, other: int) -> int;
    @intrinsic fn __bit_and(self: int, other: int) -> int;
    @intrinsic fn __bit_or(self: int, other: int) -> int;
    @intrinsic fn __bit_xor(self: int, other: int) -> int;
    @intrinsic fn __shl(self: int, other: int) -> int;
    @intrinsic fn __shr(self: int, other: int) -> int;
    @intrinsic fn __lt(self: int, other: int) -> bool;
    @intrinsic fn __le(self: int, other: int) -> bool;
    @intrinsic fn __eq(self: int, other: int) -> bool;
    @intrinsic fn __ne(self: int, other: int) -> bool;
    @intrinsic fn __ge(self: int, other: int) -> bool;
    @intrinsic fn __gt(self: int, other: int) -> bool;
    @intrinsic fn __pos(self: int) -> int;
    @intrinsic fn __neg(self: int) -> int;
    @intrinsic fn __abs(self: int) -> int;
    @intrinsic fn __to(self: int, target: string) -> string;
    @overload pub fn __to(self: &int, _: string) -> string {
        return (*self) to string;
    }
    @intrinsic @overload fn __to(self: int, target: float) -> float;
    @intrinsic @overload fn __to(self: int, target: uint) -> uint;
    @intrinsic @overload fn __to(self: int, target: int8) -> int8;
    @intrinsic @overload fn __to(self: int, target: int16) -> int16;
    @intrinsic @overload fn __to(self: int, target: int32) -> int32;
    @intrinsic @overload fn __to(self: int, target: int64) -> int64;
    @intrinsic @overload fn __to(self: int, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: int, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: int, target: uint32) -> uint32;
    @intrinsic @overload fn __to(self: int, target: uint64) -> uint64;
    @intrinsic @overload fn __to(self: int, target: float16) -> float16;
    @intrinsic @overload fn __to(self: int, target: float32) -> float32;
    @intrinsic @overload fn __to(self: int, target: float64) -> float64;
    // Parse int from string (for @entrypoint("argv") support)
    @intrinsic pub fn from_str(s: &string) -> Erring<int, Error>;
}

extern<uint> {
    @intrinsic fn __add(self: uint, other: uint) -> uint;
    @intrinsic fn __sub(self: uint, other: uint) -> uint;
    @intrinsic fn __mul(self: uint, other: uint) -> uint;
    @intrinsic fn __div(self: uint, other: uint) -> uint;
    @intrinsic fn __mod(self: uint, other: uint) -> uint;
    @intrinsic fn __bit_and(self: uint, other: uint) -> uint;
    @intrinsic fn __bit_or(self: uint, other: uint) -> uint;
    @intrinsic fn __bit_xor(self: uint, other: uint) -> uint;
    @intrinsic fn __shl(self: uint, other: uint) -> uint;
    @intrinsic fn __shr(self: uint, other: uint) -> uint;
    @intrinsic fn __lt(self: uint, other: uint) -> bool;
    @intrinsic fn __le(self: uint, other: uint) -> bool;
    @intrinsic fn __eq(self: uint, other: uint) -> bool;
    @intrinsic fn __ne(self: uint, other: uint) -> bool;
    @intrinsic fn __ge(self: uint, other: uint) -> bool;
    @intrinsic fn __gt(self: uint, other: uint) -> bool;
    @intrinsic fn __pos(self: uint) -> uint;
    @intrinsic fn __abs(self: uint) -> uint;
    @intrinsic fn __to(self: uint, target: string) -> string;
    @overload pub fn __to(self: &uint, _: string) -> string {
        return (*self) to string;
    }
    @intrinsic @overload fn __to(self: uint, target: int) -> int;
    @intrinsic @overload fn __to(self: uint, target: float) -> float;
    @intrinsic @overload fn __to(self: uint, target: int8) -> int8;
    @intrinsic @overload fn __to(self: uint, target: int16) -> int16;
    @intrinsic @overload fn __to(self: uint, target: int32) -> int32;
    @intrinsic @overload fn __to(self: uint, target: int64) -> int64;
    @intrinsic @overload fn __to(self: uint, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: uint, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: uint, target: uint32) -> uint32;
    @intrinsic @overload fn __to(self: uint, target: uint64) -> uint64;
    @intrinsic @overload fn __to(self: uint, target: float16) -> float16;
    @intrinsic @overload fn __to(self: uint, target: float32) -> float32;
    @intrinsic @overload fn __to(self: uint, target: float64) -> float64;
    // Parse uint from string (for @entrypoint("argv") support)
    @intrinsic pub fn from_str(s: &string) -> Erring<uint, Error>;
}

extern<int8> {
    pub fn __min_value() -> int8 { return (-128):int8; }
    pub fn __max_value() -> int8 { return (127):int8; }
    @intrinsic fn __add(self: int8, other: int8) -> int8;
    @intrinsic fn __sub(self: int8, other: int8) -> int8;
    @intrinsic fn __mul(self: int8, other: int8) -> int8;
    @intrinsic fn __div(self: int8, other: int8) -> int8;
    @intrinsic fn __mod(self: int8, other: int8) -> int8;
    @intrinsic fn __bit_and(self: int8, other: int8) -> int8;
    @intrinsic fn __bit_or(self: int8, other: int8) -> int8;
    @intrinsic fn __bit_xor(self: int8, other: int8) -> int8;
    @intrinsic fn __shl(self: int8, other: int8) -> int8;
    @intrinsic fn __shr(self: int8, other: int8) -> int8;
    @intrinsic fn __lt(self: int8, other: int8) -> bool;
    @intrinsic fn __le(self: int8, other: int8) -> bool;
    @intrinsic fn __eq(self: int8, other: int8) -> bool;
    @intrinsic fn __ne(self: int8, other: int8) -> bool;
    @intrinsic fn __ge(self: int8, other: int8) -> bool;
    @intrinsic fn __gt(self: int8, other: int8) -> bool;
    @intrinsic fn __pos(self: int8) -> int8;
    @intrinsic fn __neg(self: int8) -> int8;
    @intrinsic fn __abs(self: int8) -> int8;
    @intrinsic fn __to(self: int8, target: int) -> int;
    @intrinsic @overload fn __to(self: int8, target: int16) -> int16;
    @intrinsic @overload fn __to(self: int8, target: int32) -> int32;
    @intrinsic @overload fn __to(self: int8, target: int64) -> int64;
    @intrinsic pub fn from_str(s: &string) -> Erring<int8, Error>;
}

extern<int16> {
    pub fn __min_value() -> int16 { return (-32_768):int16; }
    pub fn __max_value() -> int16 { return (32_767):int16; }
    @intrinsic fn __add(self: int16, other: int16) -> int16;
    @intrinsic fn __sub(self: int16, other: int16) -> int16;
    @intrinsic fn __mul(self: int16, other: int16) -> int16;
    @intrinsic fn __div(self: int16, other: int16) -> int16;
    @intrinsic fn __mod(self: int16, other: int16) -> int16;
    @intrinsic fn __bit_and(self: int16, other: int16) -> int16;
    @intrinsic fn __bit_or(self: int16, other: int16) -> int16;
    @intrinsic fn __bit_xor(self: int16, other: int16) -> int16;
    @intrinsic fn __shl(self: int16, other: int16) -> int16;
    @intrinsic fn __shr(self: int16, other: int16) -> int16;
    @intrinsic fn __lt(self: int16, other: int16) -> bool;
    @intrinsic fn __le(self: int16, other: int16) -> bool;
    @intrinsic fn __eq(self: int16, other: int16) -> bool;
    @intrinsic fn __ne(self: int16, other: int16) -> bool;
    @intrinsic fn __ge(self: int16, other: int16) -> bool;
    @intrinsic fn __gt(self: int16, other: int16) -> bool;
    @intrinsic fn __pos(self: int16) -> int16;
    @intrinsic fn __neg(self: int16) -> int16;
    @intrinsic fn __abs(self: int16) -> int16;
    @intrinsic fn __to(self: int16, target: int) -> int;
    @intrinsic @overload fn __to(self: int16, target: int8) -> int8;
    @intrinsic @overload fn __to(self: int16, target: int32) -> int32;
    @intrinsic @overload fn __to(self: int16, target: int64) -> int64;
    @intrinsic pub fn from_str(s: &string) -> Erring<int16, Error>;
}

extern<int32> {
    pub fn __min_value() -> int32 { return (-2_147_483_648):int32; }
    pub fn __max_value() -> int32 { return (2_147_483_647):int32; }
    @intrinsic fn __add(self: int32, other: int32) -> int32;
    @intrinsic fn __sub(self: int32, other: int32) -> int32;
    @intrinsic fn __mul(self: int32, other: int32) -> int32;
    @intrinsic fn __div(self: int32, other: int32) -> int32;
    @intrinsic fn __mod(self: int32, other: int32) -> int32;
    @intrinsic fn __bit_and(self: int32, other: int32) -> int32;
    @intrinsic fn __bit_or(self: int32, other: int32) -> int32;
    @intrinsic fn __bit_xor(self: int32, other: int32) -> int32;
    @intrinsic fn __shl(self: int32, other: int32) -> int32;
    @intrinsic fn __shr(self: int32, other: int32) -> int32;
    @intrinsic fn __lt(self: int32, other: int32) -> bool;
    @intrinsic fn __le(self: int32, other: int32) -> bool;
    @intrinsic fn __eq(self: int32, other: int32) -> bool;
    @intrinsic fn __ne(self: int32, other: int32) -> bool;
    @intrinsic fn __ge(self: int32, other: int32) -> bool;
    @intrinsic fn __gt(self: int32, other: int32) -> bool;
    @intrinsic fn __pos(self: int32) -> int32;
    @intrinsic fn __neg(self: int32) -> int32;
    @intrinsic fn __abs(self: int32) -> int32;
    @intrinsic fn __to(self: int32, target: int) -> int;
    @intrinsic @overload fn __to(self: int32, target: int8) -> int8;
    @intrinsic @overload fn __to(self: int32, target: int16) -> int16;
    @intrinsic @overload fn __to(self: int32, target: int64) -> int64;
    @intrinsic pub fn from_str(s: &string) -> Erring<int32, Error>;
}

extern<int64> {
    pub fn __min_value() -> int64 { return (-9_223_372_036_854_775_808):int64; }
    pub fn __max_value() -> int64 { return (9_223_372_036_854_775_807):int64; }
    @intrinsic fn __add(self: int64, other: int64) -> int64;
    @intrinsic fn __sub(self: int64, other: int64) -> int64;
    @intrinsic fn __mul(self: int64, other: int64) -> int64;
    @intrinsic fn __div(self: int64, other: int64) -> int64;
    @intrinsic fn __mod(self: int64, other: int64) -> int64;
    @intrinsic fn __bit_and(self: int64, other: int64) -> int64;
    @intrinsic fn __bit_or(self: int64, other: int64) -> int64;
    @intrinsic fn __bit_xor(self: int64, other: int64) -> int64;
    @intrinsic fn __shl(self: int64, other: int64) -> int64;
    @intrinsic fn __shr(self: int64, other: int64) -> int64;
    @intrinsic fn __lt(self: int64, other: int64) -> bool;
    @intrinsic fn __le(self: int64, other: int64) -> bool;
    @intrinsic fn __eq(self: int64, other: int64) -> bool;
    @intrinsic fn __ne(self: int64, other: int64) -> bool;
    @intrinsic fn __ge(self: int64, other: int64) -> bool;
    @intrinsic fn __gt(self: int64, other: int64) -> bool;
    @intrinsic fn __pos(self: int64) -> int64;
    @intrinsic fn __neg(self: int64) -> int64;
    @intrinsic fn __abs(self: int64) -> int64;
    @intrinsic fn __to(self: int64, target: int) -> int;
    @intrinsic @overload fn __to(self: int64, target: int8) -> int8;
    @intrinsic @overload fn __to(self: int64, target: int16) -> int16;
    @intrinsic @overload fn __to(self: int64, target: int32) -> int32;
    @intrinsic pub fn from_str(s: &string) -> Erring<int64, Error>;
}

extern<uint8> {
    pub fn __min_value() -> uint8 { return (0):uint8; }
    pub fn __max_value() -> uint8 { return (255):uint8; }
    @intrinsic fn __add(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __sub(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __mul(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __div(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __mod(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __bit_and(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __bit_or(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __bit_xor(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __shl(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __shr(self: uint8, other: uint8) -> uint8;
    @intrinsic fn __lt(self: uint8, other: uint8) -> bool;
    @intrinsic fn __le(self: uint8, other: uint8) -> bool;
    @intrinsic fn __eq(self: uint8, other: uint8) -> bool;
    @intrinsic fn __ne(self: uint8, other: uint8) -> bool;
    @intrinsic fn __ge(self: uint8, other: uint8) -> bool;
    @intrinsic fn __gt(self: uint8, other: uint8) -> bool;
    @intrinsic fn __pos(self: uint8) -> uint8;
    @intrinsic fn __abs(self: uint8) -> uint8;
    @intrinsic fn __to(self: uint8, target: uint) -> uint;
    @intrinsic @overload fn __to(self: uint8, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: uint8, target: uint32) -> uint32;
    @intrinsic @overload fn __to(self: uint8, target: uint64) -> uint64;
    @intrinsic pub fn from_str(s: &string) -> Erring<uint8, Error>;
}

extern<uint16> {
    pub fn __min_value() -> uint16 { return (0):uint16; }
    pub fn __max_value() -> uint16 { return (65_535):uint16; }
    @intrinsic fn __add(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __sub(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __mul(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __div(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __mod(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __bit_and(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __bit_or(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __bit_xor(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __shl(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __shr(self: uint16, other: uint16) -> uint16;
    @intrinsic fn __lt(self: uint16, other: uint16) -> bool;
    @intrinsic fn __le(self: uint16, other: uint16) -> bool;
    @intrinsic fn __eq(self: uint16, other: uint16) -> bool;
    @intrinsic fn __ne(self: uint16, other: uint16) -> bool;
    @intrinsic fn __ge(self: uint16, other: uint16) -> bool;
    @intrinsic fn __gt(self: uint16, other: uint16) -> bool;
    @intrinsic fn __pos(self: uint16) -> uint16;
    @intrinsic fn __abs(self: uint16) -> uint16;
    @intrinsic fn __to(self: uint16, target: uint) -> uint;
    @intrinsic @overload fn __to(self: uint16, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: uint16, target: uint32) -> uint32;
    @intrinsic @overload fn __to(self: uint16, target: uint64) -> uint64;
    @intrinsic pub fn from_str(s: &string) -> Erring<uint16, Error>;
}

extern<uint32> {
    pub fn __min_value() -> uint32 { return (0):uint32; }
    pub fn __max_value() -> uint32 { return (4_294_967_295):uint32; }
    @intrinsic fn __add(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __sub(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __mul(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __div(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __mod(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __bit_and(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __bit_or(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __bit_xor(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __shl(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __shr(self: uint32, other: uint32) -> uint32;
    @intrinsic fn __lt(self: uint32, other: uint32) -> bool;
    @intrinsic fn __le(self: uint32, other: uint32) -> bool;
    @intrinsic fn __eq(self: uint32, other: uint32) -> bool;
    @intrinsic fn __ne(self: uint32, other: uint32) -> bool;
    @intrinsic fn __ge(self: uint32, other: uint32) -> bool;
    @intrinsic fn __gt(self: uint32, other: uint32) -> bool;
    @intrinsic fn __pos(self: uint32) -> uint32;
    @intrinsic fn __abs(self: uint32) -> uint32;
    @intrinsic fn __to(self: uint32, target: uint) -> uint;
    @intrinsic @overload fn __to(self: uint32, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: uint32, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: uint32, target: uint64) -> uint64;
    @intrinsic pub fn from_str(s: &string) -> Erring<uint32, Error>;
}

extern<uint64> {
    pub fn __min_value() -> uint64 { return (0):uint64; }
    pub fn __max_value() -> uint64 { return (18_446_744_073_709_551_615):uint64; }
    @intrinsic fn __add(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __sub(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __mul(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __div(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __mod(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __bit_and(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __bit_or(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __bit_xor(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __shl(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __shr(self: uint64, other: uint64) -> uint64;
    @intrinsic fn __lt(self: uint64, other: uint64) -> bool;
    @intrinsic fn __le(self: uint64, other: uint64) -> bool;
    @intrinsic fn __eq(self: uint64, other: uint64) -> bool;
    @intrinsic fn __ne(self: uint64, other: uint64) -> bool;
    @intrinsic fn __ge(self: uint64, other: uint64) -> bool;
    @intrinsic fn __gt(self: uint64, other: uint64) -> bool;
    @intrinsic fn __pos(self: uint64) -> uint64;
    @intrinsic fn __abs(self: uint64) -> uint64;
    @intrinsic fn __to(self: uint64, target: uint) -> uint;
    @intrinsic @overload fn __to(self: uint64, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: uint64, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: uint64, target: uint32) -> uint32;
    @intrinsic pub fn from_str(s: &string) -> Erring<uint64, Error>;
}

extern<float16> {
    pub fn __min_value() -> float16 { return (-65504.0):float16; }
    pub fn __max_value() -> float16 { return (65504.0):float16; }
    @intrinsic fn __add(self: float16, other: float16) -> float16;
    @intrinsic fn __sub(self: float16, other: float16) -> float16;
    @intrinsic fn __mul(self: float16, other: float16) -> float16;
    @intrinsic fn __div(self: float16, other: float16) -> float16;
    @intrinsic fn __mod(self: float16, other: float16) -> float16;
    @intrinsic fn __lt(self: float16, other: float16) -> bool;
    @intrinsic fn __le(self: float16, other: float16) -> bool;
    @intrinsic fn __eq(self: float16, other: float16) -> bool;
    @intrinsic fn __ne(self: float16, other: float16) -> bool;
    @intrinsic fn __ge(self: float16, other: float16) -> bool;
    @intrinsic fn __gt(self: float16, other: float16) -> bool;
    @intrinsic fn __pos(self: float16) -> float16;
    @intrinsic fn __neg(self: float16) -> float16;
    @intrinsic fn __abs(self: float16) -> float16;
    @intrinsic fn __to(self: float16, target: float) -> float;
    @intrinsic @overload fn __to(self: float16, target: float32) -> float32;
    @intrinsic @overload fn __to(self: float16, target: float64) -> float64;
    @intrinsic pub fn from_str(s: &string) -> Erring<float16, Error>;
}

extern<float32> {
    pub fn __min_value() -> float32 { return (-3.402_823_466_385_2886e+38):float32; }
    pub fn __max_value() -> float32 { return (3.402_823_466_385_2886e+38):float32; }
    @intrinsic fn __add(self: float32, other: float32) -> float32;
    @intrinsic fn __sub(self: float32, other: float32) -> float32;
    @intrinsic fn __mul(self: float32, other: float32) -> float32;
    @intrinsic fn __div(self: float32, other: float32) -> float32;
    @intrinsic fn __mod(self: float32, other: float32) -> float32;
    @intrinsic fn __lt(self: float32, other: float32) -> bool;
    @intrinsic fn __le(self: float32, other: float32) -> bool;
    @intrinsic fn __eq(self: float32, other: float32) -> bool;
    @intrinsic fn __ne(self: float32, other: float32) -> bool;
    @intrinsic fn __ge(self: float32, other: float32) -> bool;
    @intrinsic fn __gt(self: float32, other: float32) -> bool;
    @intrinsic fn __pos(self: float32) -> float32;
    @intrinsic fn __neg(self: float32) -> float32;
    @intrinsic fn __abs(self: float32) -> float32;
    @intrinsic fn __to(self: float32, target: float) -> float;
    @intrinsic @overload fn __to(self: float32, target: float16) -> float16;
    @intrinsic @overload fn __to(self: float32, target: float64) -> float64;
    @intrinsic pub fn from_str(s: &string) -> Erring<float32, Error>;
}

extern<float64> {
    pub fn __min_value() -> float64 { return (-1.797_693_134_862_3157e+308):float64; }
    pub fn __max_value() -> float64 { return (1.797_693_134_862_3157e+308):float64; }
    @intrinsic fn __add(self: float64, other: float64) -> float64;
    @intrinsic fn __sub(self: float64, other: float64) -> float64;
    @intrinsic fn __mul(self: float64, other: float64) -> float64;
    @intrinsic fn __div(self: float64, other: float64) -> float64;
    @intrinsic fn __mod(self: float64, other: float64) -> float64;
    @intrinsic fn __lt(self: float64, other: float64) -> bool;
    @intrinsic fn __le(self: float64, other: float64) -> bool;
    @intrinsic fn __eq(self: float64, other: float64) -> bool;
    @intrinsic fn __ne(self: float64, other: float64) -> bool;
    @intrinsic fn __ge(self: float64, other: float64) -> bool;
    @intrinsic fn __gt(self: float64, other: float64) -> bool;
    @intrinsic fn __pos(self: float64) -> float64;
    @intrinsic fn __neg(self: float64) -> float64;
    @intrinsic fn __abs(self: float64) -> float64;
    @intrinsic fn __to(self: float64, target: float) -> float;
    @intrinsic @overload fn __to(self: float64, target: float16) -> float16;
    @intrinsic @overload fn __to(self: float64, target: float32) -> float32;
    @intrinsic pub fn from_str(s: &string) -> Erring<float64, Error>;
}

extern<float> {
    @intrinsic fn __add(self: float, other: float) -> float;
    @intrinsic fn __sub(self: float, other: float) -> float;
    @intrinsic fn __mul(self: float, other: float) -> float;
    @intrinsic fn __div(self: float, other: float) -> float;
    @intrinsic fn __mod(self: float, other: float) -> float;
    @intrinsic fn __lt(self: float, other: float) -> bool;
    @intrinsic fn __le(self: float, other: float) -> bool;
    @intrinsic fn __eq(self: float, other: float) -> bool;
    @intrinsic fn __ne(self: float, other: float) -> bool;
    @intrinsic fn __ge(self: float, other: float) -> bool;
    @intrinsic fn __gt(self: float, other: float) -> bool;
    @intrinsic fn __pos(self: float) -> float;
    @intrinsic fn __neg(self: float) -> float;
    @intrinsic fn __abs(self: float) -> float;
    @intrinsic fn __to(self: float, target: string) -> string;
    @overload pub fn __to(self: &float, _: string) -> string {
        return (*self) to string;
    }
    @intrinsic @overload fn __to(self: float, target: int) -> int;
    @intrinsic @overload fn __to(self: float, target: uint) -> uint;
    @intrinsic @overload fn __to(self: float, target: int8) -> int8;
    @intrinsic @overload fn __to(self: float, target: int16) -> int16;
    @intrinsic @overload fn __to(self: float, target: int32) -> int32;
    @intrinsic @overload fn __to(self: float, target: int64) -> int64;
    @intrinsic @overload fn __to(self: float, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: float, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: float, target: uint32) -> uint32;
    @intrinsic @overload fn __to(self: float, target: uint64) -> uint64;
    @intrinsic @overload fn __to(self: float, target: float16) -> float16;
    @intrinsic @overload fn __to(self: float, target: float32) -> float32;
    @intrinsic @overload fn __to(self: float, target: float64) -> float64;
    // Parse float from string (for @entrypoint("argv") support)
    @intrinsic pub fn from_str(s: &string) -> Erring<float, Error>;
}

extern<string> {
    @intrinsic fn __add(self: &string, other: &string) -> string;
    @intrinsic fn __mul(self: &string, other: int) -> string;
    @overload pub fn __mul(self: &string, other: uint) -> string {
        return self * (other to int);
    }
    @intrinsic fn __eq(self: &string, other: &string) -> bool;
    @intrinsic fn __ne(self: &string, other: &string) -> bool;
    @intrinsic fn __to(self: &string, target: int) -> int;
    @intrinsic @overload fn __to(self: &string, target: uint) -> uint;
    @intrinsic @overload fn __to(self: &string, target: float) -> float;
    @overload pub fn __to(self: &string, _: string) -> string {
        return self.__clone();
    }
    @intrinsic fn __len(self: &string) -> uint;
    @intrinsic fn __clone(self: &string) -> string;
    @intrinsic @overload fn __index(self: &string, index: int) -> uint32;
    @intrinsic @overload fn __index(self: &string, index: Range<int>) -> string;
}

@intrinsic
pub type BytesView = {
    owner: string,
    ptr: *byte,
    len: uint,
};

extern<BytesView> {
    @intrinsic fn __len(self: &BytesView) -> uint;
    @intrinsic fn __index(self: &BytesView, index: int) -> uint8;
}

extern<bool> {
    @intrinsic fn __eq(self: bool, other: bool) -> bool;
    @intrinsic fn __ne(self: bool, other: bool) -> bool;
    @intrinsic fn __not(self: bool) -> bool;
    @intrinsic fn __to(self: bool, target: string) -> string;
    @overload pub fn __to(self: &bool, _: string) -> string {
        return (*self) to string;
    }
    @intrinsic @overload fn __to(self: bool, target: int) -> int;
    // Parse bool from string (for @entrypoint("argv") support)
    @intrinsic pub fn from_str(s: &string) -> Erring<bool, Error>;
}

extern<Array<T>> {
    @intrinsic fn __add(self: &Array<T>, other: &Array<T>) -> Array<T>;
    @intrinsic fn __index(self: &Array<T>, index: int) -> &T;
    @intrinsic @overload fn __index(self: &Array<T>, index: Range<int>) -> Array<T>;
    @intrinsic fn __index_set(self: &mut Array<T>, index: int, value: T) -> nothing;
    @intrinsic fn __range(self: &Array<T>) -> Range<T>;
    @intrinsic fn __len(self: &Array<T>) -> uint;
}

extern<ArrayFixed<T, N>> {
    @intrinsic fn __add(self: &ArrayFixed<T, N>, other: &ArrayFixed<T, N>) -> ArrayFixed<T, N>;
    @intrinsic fn __index(self: &ArrayFixed<T, N>, index: int) -> &T;
    @intrinsic @overload fn __index(self: &ArrayFixed<T, N>, index: Range<int>) -> Array<T>;
    @intrinsic fn __index_set(self: &mut ArrayFixed<T, N>, index: int, value: T) -> nothing;
    @intrinsic fn __range(self: &ArrayFixed<T, N>) -> Range<T>;
    @intrinsic fn __len(self: &ArrayFixed<T, N>) -> uint;
}

@intrinsic
pub fn default<T>() -> T;

@intrinsic
pub fn size_of<T>() -> uint;

@intrinsic
pub fn align_of<T>() -> uint;

pub contract ErrorLike{
    field message: string;
    field code: uint;
}

@intrinsic
pub fn exit<E>(e: E) -> nothing;

pub fn panic(msg: string) -> nothing {
    let e: Error = { message: msg, code: 1:uint };
    exit(e);
}

@intrinsic
pub type Mutex = {
    __opaque: *byte,
};

extern<Mutex> {
    @intrinsic pub fn new() -> Mutex;
    @intrinsic pub fn lock(self: &mut Mutex) -> nothing;
    @intrinsic pub fn unlock(self: &mut Mutex) -> nothing;
    @intrinsic pub fn try_lock(self: &mut Mutex) -> bool;
}

@intrinsic
pub type RwLock = {
    __opaque: *byte,
};

extern<RwLock> {
    @intrinsic pub fn new() -> RwLock;
    @intrinsic pub fn read_lock(self: &mut RwLock) -> nothing;
    @intrinsic pub fn read_unlock(self: &mut RwLock) -> nothing;
    @intrinsic pub fn write_lock(self: &mut RwLock) -> nothing;
    @intrinsic pub fn write_unlock(self: &mut RwLock) -> nothing;
    @intrinsic pub fn try_read_lock(self: &mut RwLock) -> bool;
    @intrinsic pub fn try_write_lock(self: &mut RwLock) -> bool;
}

@intrinsic
pub type Condition = {
    __opaque: *byte,
};

extern<Condition> {
    @intrinsic pub fn new() -> Condition;
    @intrinsic pub fn wait(self: &Condition, mutex: &mut Mutex) -> nothing;
    @intrinsic pub fn notify_one(self: &Condition) -> nothing;
    @intrinsic pub fn notify_all(self: &Condition) -> nothing;
}

@intrinsic
pub type Semaphore = {
    __opaque: *byte,
    __count: uint,
};

extern<Semaphore> {
    @intrinsic pub fn new(count: uint) -> Semaphore;
    @intrinsic pub fn acquire(self: &mut Semaphore) -> nothing;
    @intrinsic pub fn release(self: &mut Semaphore) -> nothing;
    @intrinsic pub fn try_acquire(self: &mut Semaphore) -> bool;
}

// Atomic operations for @atomic fields
// These intrinsics provide thread-safe access to atomic fields.
// All operations use sequentially-consistent (SeqCst) memory ordering,
// providing the strongest guarantees for cross-task visibility.

// Atomic load - read a value atomically
@intrinsic
pub fn atomic_load(ptr: &int) -> int;

@intrinsic
@overload
pub fn atomic_load(ptr: &uint) -> uint;

@intrinsic
@overload
pub fn atomic_load(ptr: &bool) -> bool;

// Atomic store - write a value atomically
@intrinsic
pub fn atomic_store(ptr: &mut int, value: int) -> nothing;

@intrinsic
@overload
pub fn atomic_store(ptr: &mut uint, value: uint) -> nothing;

@intrinsic
@overload
pub fn atomic_store(ptr: &mut bool, value: bool) -> nothing;

// Atomic exchange - atomically replace value and return old value
@intrinsic
pub fn atomic_exchange(ptr: &mut int, new_val: int) -> int;

@intrinsic
@overload
pub fn atomic_exchange(ptr: &mut uint, new_val: uint) -> uint;

@intrinsic
@overload
pub fn atomic_exchange(ptr: &mut bool, new_val: bool) -> bool;

// Atomic compare and exchange - atomically compare and swap
// Returns true if exchange succeeded (value was expected)
@intrinsic
pub fn atomic_compare_exchange(ptr: &mut int, expected: int, desired: int) -> bool;

@intrinsic
@overload
pub fn atomic_compare_exchange(ptr: &mut uint, expected: uint, desired: uint) -> bool;

@intrinsic
@overload
pub fn atomic_compare_exchange(ptr: &mut bool, expected: bool, desired: bool) -> bool;

// Atomic fetch and add - atomically add to value and return old value
@intrinsic
pub fn atomic_fetch_add(ptr: &mut int, delta: int) -> int;

@intrinsic
@overload
pub fn atomic_fetch_add(ptr: &mut uint, delta: uint) -> uint;

// Atomic fetch and subtract - atomically subtract from value and return old value
@intrinsic
pub fn atomic_fetch_sub(ptr: &mut int, delta: int) -> int;

@intrinsic
@overload
pub fn atomic_fetch_sub(ptr: &mut uint, delta: uint) -> uint;

// Runtime intrinsics for __surge_start entrypoint wrapper

// Get command-line arguments as string array
@intrinsic
pub fn rt_argv() -> string[];

// Read all content from stdin
@intrinsic
pub fn rt_stdin_read_all() -> string;

// Exit with integer exit code (for __surge_start)
@intrinsic
pub fn rt_exit(code: int) -> nothing;
