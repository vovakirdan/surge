// ยง2.3 Ownership & References Audit

// NOTE: Ownership modifiers create distinct types from base types
// own int != int, &int != int
// Casting &T to string not supported

type Point = { x: int, y: int }

extern<Point> {
    fn sum(self: &Point) -> int {
        return self.x + self.y;
    }
}

@entrypoint
fn main() {
    // Basic reference creation
    let val: int = 10;
    let ref_val: &int = &val;

    // &mut T - exclusive mutable borrow
    let mut mutable_val: int = 5;
    let mut_ref: &mut int = &mut mutable_val;
    *mut_ref = 6;

    // Explicit ownership move for non-Copy
    let s: string = "hello";
    let os: own string = own s;

    // Copy compatibility between T and own T
    let c: int = 10;
    let oc: own int = c;
    let c2: int = oc;

    // @drop ends borrow early
    let mut z: int = 1;
    let rz: &int = &z;
    @drop rz;
    z = 2;

    // Raw pointers (*T) are backend-only; not permitted in user code (v1/v2).

    // &self methods should work at runtime
    let p: Point = { x: 2, y: 3 };
    let total: int = p.sum();
    print("Sum: " + total to string);

    print("ยง2.3 Ownership: PASS (refs + &self methods)");
}
