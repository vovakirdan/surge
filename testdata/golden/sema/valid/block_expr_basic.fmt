// scenario: block expressions with return
fn test_block_expr() -> int {
    let x: int = {
        let a: int = 10;
        let b: int = 20;
        return a + b;
    };
    return x;
}

fn test_nested_block_expr() -> int {
    // Block expression inside block expression
    let y: int = {
        let outer: int = 5;
        return {
            let inner: int = outer * 2;
            return inner;
        };
    };
    return y;
}
