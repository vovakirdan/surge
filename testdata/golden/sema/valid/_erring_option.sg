// scenario: check erring and option types methods

fn return_option() -> Option<int> {
    return Some(100);
}

fn return_erring() -> Erring<int, Error> {
    return Success(100);
}

fn test_option_safe_method() -> bool {
    let option: int? = return_option(); // of course we can use int? sugar
    let value: int = option.safe(); // safe guarantees you that "it always returns a value"
    // but be careful, if option is nothing, safe will return default value for T, which is defined by default::<T>()
    if (value == 0) {
        return false; 
    }
    return true;
}

fn test_option_panic_method() -> int? {
    let option: int? = return_option(); // of course we can use int? sugar
    option.panic("Option is nothing"); // panic will return nothing if option is nothing
    // but otherwise it will panic
    return option;
}

fn test_erring_safe_method() -> bool {
    let erring: int! = return_erring(); // of course we can use int! sugar
    let value: int = erring.safe(); // safe guarantees you that "it always returns a value"
    // and here we ignore the error
    // but be careful, if erring is error, safe will return default value for T, which is defined by default::<T>()
    if (value == 0) {
        return false; 
    }
    return true;
}

fn test_erring_exit_method() -> nothing {
    let erring: int! = return_erring(); // of course we can use int! sugar
    erring.exit(); // exit will exit with that error if there is one
    // but otherwise it will do nothing
    return nothing;
}
