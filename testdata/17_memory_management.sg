// Управление памятью и lifetime
fn test_basic_ownership() -> int {
    // Stack allocation
    let stack_value: int = 42;
    let stack_array: int[5] = [1, 2, 3, 4, 5];

    // Heap allocation с explicit ownership
    let owned_string: own string = own "Hello, World!";
    let owned_vector: own int[] = own [1, 2, 3, 4, 5];

    // Move semantics
    let moved_string: own string = own owned_string;
    // owned_string больше не доступен

    return stack_value + moved_string.len_chars();
}

fn test_borrowing_lifetimes() -> int {
    let mut data: int = 100;

    // Immutable borrowing
    let ref1: &int = &data;
    let ref2: &int = &data; // Множественные immutable refs OK

    // Mutable borrowing
    let mut_ref: &mut int = &mut data;
    *mut_ref = *mut_ref + 50;

    // ref1 и ref2 больше не действительны после mut_ref

    return data; // 150
}

// Lifetime annotations
fn longest_string<'a>(s1: &'a string, s2: &'a string) -> &'a string {
    return compare s1.len_chars() > s2.len_chars() {
        true => s1,
        false => s2
    };
}

// Reference counting
type Rc<T> = {
    @shared data: T,
    @atomic ref_count: int
}

fn create_shared_data<T>(value: T) -> Rc<T> {
    return Rc {
        data: value,
        ref_count: 1
    };
}

fn clone_rc<T>(rc: &Rc<T>) -> Rc<T> {
    atomic_increment(&rc.ref_count);
    return Rc {
        data: rc.data,
        ref_count: rc.ref_count
    };
}

// Weak references
type Weak<T> = {
    @weak data: *T
}

fn downgrade_rc<T>(rc: &Rc<T>) -> Weak<T> {
    return Weak {
        data: &rc.data as *T
    };
}

// Memory pools
type MemoryPool<T> = {
    @arena chunks: T[],
    @atomic free_list: *T
}

fn allocate_from_pool<T>(pool: &mut MemoryPool<T>) -> Option<&mut T> {
    // Pool allocation logic
    return nothing; // simplified
}

// RAII и automatic cleanup
type FileHandle = {
    @raii handle: int
}

extern<FileHandle> {
    fn drop(&mut self) {
        close_file(self.handle);
    }
}

fn open_file_safe(path: string) -> Option<FileHandle> {
    let handle: int = open_file(path);
    return compare handle {
        -1 => nothing,
        h => Some(FileHandle { handle: h })
    };
}

// Arena allocation
type Arena = {
    @arena memory: uint8[],
    @atomic offset: int
}

fn create_arena(size: int) -> Arena {
    return Arena {
        memory: allocate_bytes(size),
        offset: 0
    };
}

fn arena_allocate<T>(arena: &mut Arena, value: T) -> &mut T {
    let size: int = size_of<T>();
    let aligned_offset: int = align_up(arena.offset, align_of<T>());

    arena.offset = aligned_offset + size;
    let ptr: *T = &arena.memory[aligned_offset] as *T;
    write_to_ptr(ptr, value);

    return ptr as &mut T;
}

// Stack vs Heap allocation strategies
fn allocation_strategies() -> int {
    // Stack allocation (быстро, ограниченный размер)
    let small_array: int[10] = [0; 10];

    // Heap allocation (медленнее, гибкий размер)
    let large_vector: own int[] = allocate_vector(1000000);

    // Memory-mapped allocation для больших данных
    let huge_data: own uint8[] = mmap_allocate(1_000_000_000);

    return small_array.len() + large_vector.len() + huge_data.len();
}

// Custom allocators
// Note: trait syntax not defined in specification
// Allocator behavior would be defined via extern<T> blocks

type MallocAllocator = {}

extern<MallocAllocator> {
    fn allocate(&mut self, size: int, align: int) -> *uint8 {
        return malloc_aligned(size, align);
    }

    fn deallocate(&mut self, ptr: *uint8, size: int, align: int) {
        free(ptr);
    }
}

// Memory-safe collections
type SafeVector<T> = {
    @owned data: T[],
    capacity: int,
    length: int
}

extern<SafeVector<T>> {
    fn new() -> SafeVector<T> {
        return SafeVector {
            data: [],
            capacity: 0,
            length: 0
        };
    }

    fn push(&mut self, item: T) {
        if (self.length >= self.capacity) {
            self.grow();
        }
        self.data[self.length] = item;
        self.length = self.length + 1;
    }

    fn get(&self, index: int) -> Option<&T> {
        return compare index < self.length {
            true => Some(&self.data[index]),
            false => nothing
        };
    }

    fn grow(&mut self) {
        let new_capacity: int = compare self.capacity {
            0 => 4,
            cap => cap * 2
        };

        let new_data: T[] = allocate_array<T>(new_capacity);
        copy_array(&self.data, &new_data, self.length);

        self.data = new_data;
        self.capacity = new_capacity;
    }
}

// Memory barriers и atomic operations
fn atomic_operations() -> int {
    let mut atomic_counter: @atomic int = 0;

    // Atomic operations
    let old_value: int = atomic_fetch_add(&atomic_counter, 1);
    let current: int = atomic_load(&atomic_counter);

    // Memory barriers
    memory_barrier_acquire();
    memory_barrier_release();
    memory_barrier_full();

    return current;
}

// Unsafe memory operations
@unsafe
fn unsafe_memory_operations() -> int {
    // Raw pointer manipulation
    let data: int = 42;
    let ptr: *int = &data as *int;

    // Pointer arithmetic
    let offset_ptr: *int = ptr + 1;

    // Manual memory management
    let heap_ptr: *int = malloc(size_of<int>()) as *int;
    write_to_ptr(heap_ptr, 100);
    let value: int = read_from_ptr(heap_ptr);
    free(heap_ptr as *uint8);

    return value;
}

// Memory profiling
@profile("memory")
fn memory_profiled_function() -> int {
    let mut total_allocated: int = 0;

    for (let i: int = 0; i < 1000; i = i + 1) {
        let temp_data: own int[] = allocate_vector(100);
        total_allocated = total_allocated + temp_data.len();
        // temp_data автоматически освобождается
    }

    return total_allocated;
}

// Compile-time memory layout
@packed
type PackedData = {
    flag: bool,    // 1 byte
    value: int,    // 4 bytes immediately after
    data: float    // 4 bytes immediately after
}

@align(64)
type CacheAlignedData = {
    hot_data: int[16]  // aligned to cache line
}

// Memory debugging
// Debug attribute not defined in specification
fn debug_memory_usage() -> int {
    let usage_before: int = get_memory_usage();

    let data: own int[] = allocate_vector(1000);
    let usage_after: int = get_memory_usage();

    debug_print("Memory allocated: " + (usage_after - usage_before).to_string());

    return usage_after - usage_before;
}

// External functions for system interaction
extern fn malloc_aligned(size: int, align: int) -> *uint8;
extern fn free(ptr: *uint8);
extern fn open_file(path: string) -> int;
extern fn close_file(handle: int);
extern fn get_memory_usage() -> int;
extern fn atomic_fetch_add(ptr: *int, value: int) -> int;
extern fn atomic_load(ptr: *int) -> int;
extern fn memory_barrier_acquire();
extern fn memory_barrier_release();
extern fn memory_barrier_full();
