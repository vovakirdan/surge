// Примеры директив компилятора

// Conditional compilation
/// target: os = "linux"
fn linux_specific_function() -> string {
    return "Linux implementation";
}

/// target: os = "windows"
fn windows_specific_function() -> string {
    return "Windows implementation";
}

/// target: feature = "debug"
fn debug_function() -> string {
    return "Debug mode enabled";
}

// Import с абсолютными путями
import std/io;
import std/collections::HashMap;
import mylib/utils::{helper_function, another_helper};

// Relative imports
import ./local_module;
import ../parent_module;
import ./subdir/nested_module;

// Performance directives
/// benchmark:
/// Performance test:
///   benchmark.measure(performance_critical_function);

fn performance_critical_function() -> int {
    let mut sum: int = 0;
    for (let i: int = 0; i < 10000; i = i + 1) {
        sum = sum + i * i;
    }
    return sum;
}

/// time:
/// Execution time measurement:
///   time.measure(timed_function);

fn timed_function() -> string {
    return "This function execution time will be measured";
}

// Memory layout directives
type PackedStruct = {
    @packed a: uint8,
    @packed b: uint32,
    @packed c: uint8
}

type AlignedStruct = {
    @align(16) data: int[],
    meta: string
}

// Optimization hints
fn small_function(x: int) -> int {
    return x * 2 + 1;
}

fn large_function() -> int {
    let mut result: int = 0;
    for (let i: int = 0; i < 1000; i = i + 1) {
        result = result + i;
    }
    return result;
}

// Target-specific code
/// target: arch = "x86_64"
fn x86_optimized() -> int {
    return 64;
}

/// target: arch = "arm64"
fn arm_optimized() -> int {
    return 64;
}

// Feature flags
/// target: feature = "networking"
fn network_function() -> string {
    return "Network feature enabled";
}

/// target: feature = "database"
fn database_function() -> string {
    return "Database feature enabled";
}

// Debug информация
/// target: debug_assertions
fn debug_only_checks() -> bool {
    // Дополнительные проверки в debug режиме
    return true;
}

// Unsafe операции (если поддерживаются)
fn unsafe_pointer_operation(ptr: *int) -> int {
    return deref(ptr);
}

// External library functions
fn external_math_function() -> float {
    // Внешняя функция из библиотеки math
    return 3.14159;
}

fn ssl_function() -> string {
    return "SSL functionality";
}

// Serialization types
type SerializableData = {
    id: int,
    name: string,
    active: bool
}

// Error handling functions
fn important_result() -> Option<int> {
    return Some(42);
}

// Documentation
/// This function demonstrates directive usage
fn documented_function() -> string {
    return "well documented";
}

// Conditional methods
type ConditionalImpl = {
    value: int
}

/// target: feature = "advanced"
extern<ConditionalImpl> {
    fn advanced_method(self: &ConditionalImpl) -> int {
        return self.value * 2;
    }
}

// Complex conditional compilation
/// target: all(os = "linux", feature = "performance")
fn linux_performance_function() -> int {
    return 1000;
}

/// target: any(os = "macos", os = "ios")
fn apple_platform_function() -> string {
    return "Apple platform";
}

/// target: not(feature = "minimal")
fn full_feature_function() -> string {
    return "Full feature set available";
}

// Testing directives
/// target: test
fn test_helper() -> bool {
    return true;
}

// Main function with imports
fn test_directives() -> int {
    /// target: feature = "debug"
    let debug_result: string = debug_function();

    /// target: os = "linux"
    let os_result: string = linux_specific_function();

    let benchmark_result: int = performance_critical_function();
    let inline_result: int = small_function(21);

    return benchmark_result + inline_result;
}