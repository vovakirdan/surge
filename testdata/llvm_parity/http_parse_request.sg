import stdlib/http as http;
import stdlib/http::{parse_request, HttpVersion, Request};

fn bytes_to_ascii(bytes: byte[]) -> string {
    let length: int = bytes.__len() to int;
    if length == 0 {
        return "";
    }
    let buf = rt_alloc(1:uint, 1:uint);
    let mut out: string = "";
    let mut i: int = 0;
    while i < length {
        *buf = clone(bytes[i]);
        let piece = rt_string_from_bytes(buf, 1:uint);
        out = out + piece;
        i = i + 1;
    }
    rt_free(buf, 1:uint, 1:uint);
    return out;
}

@entrypoint
fn main() -> int {
    let raw = "GET /hello?name=surge HTTP/1.1\r\nHost: example.com\r\nContent-Length: 5\r\nX-Test: yes\r\n\r\nhello";
    let res = parse_request(&raw);
    compare res {
        Success(req) => {
            print("method=" + req.method);
            print("target=" + req.target);
            print("path=" + req.path);
            print("query=" + req.query);
            if req.version == (HttpVersion::Http11) {
                print("version=HTTP/1.1");
            }
            let count: int = req.headers.__len() to int;
            print("headers=" + (count to string));
            let mut i: int = 0;
            while i < count {
                let key: string = clone(req.headers[i].key);
                let value: string = clone(req.headers[i].value);
                print("header=" + key + ":" + value);
                i = i + 1;
            }
            let mut body = req.body;
            {
                let body_task = http.next(&mut body);
                compare body_task.await() {
                    Success(body_res) => {
                        compare body_res {
                            Success(bytes) => {
                                if bytes.__len() == 0:uint {
                                    print("body=<none>");
                                } else {
                                    print("body=" + bytes_to_ascii(bytes));
                                }
                            }
                            err => {
                                print("body_err=" + (err.code to string));
                                return 1;
                            }
                        };
                    }
                    Cancelled() => {
                        print("body_cancelled");
                        return 1;
                    }
                };
            }
            {
                let body_task = http.next(&mut body);
                compare body_task.await() {
                    Success(body_res) => {
                        compare body_res {
                            Success(bytes) => {
                                if bytes.__len() == 0:uint {
                                    print("body_end");
                                } else {
                                    print("body_extra");
                                }
                            }
                            err => {
                                print("body_err2=" + (err.code to string));
                                return 1;
                            }
                        };
                    }
                    Cancelled() => {
                        print("body_cancelled2");
                        return 1;
                    }
                };
            }
        }
        err => {
            print("parse_err=" + (err.code to string));
            return 1;
        }
    };
    return 0;
}
