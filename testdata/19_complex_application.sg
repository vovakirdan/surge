// Комплексное приложение - веб-сервер с базой данных
import std/http::{Server, Request, Response, StatusCode};
import std/json::{JSON, JsonValue};
import std/db::{Database, Connection, QueryResult};
import std/collections::{HashMap};
import std/string::{format};

// Application state
type AppState = {
    @shared database: Database,
    @shared user_cache: HashMap<UserId, User>,
    @atomic request_count: int
}

// Domain models
newtype UserId = int;

type User = {
    id: UserId,
    name: string,
    email: string,
    @readonly created_at: Timestamp,
    profile: Option<UserProfile>
}

type UserProfile = {
    bio: string,
    website: Option<string>,
    location: Option<string>
}

type CreateUserRequest = {
    name: string,
    email: string,
    profile: Option<UserProfile>
}

// Error types
error AppError {
    message: string,
    code: int
}

error ValidationError : AppError {
    field: string,
    reason: string
}

error DatabaseError : AppError {
    query: string,
    details: string
}

// Result types
alias ApiResult<T> = T | AppError;
alias UserResult = ApiResult<User>;
alias UsersResult = ApiResult<User[]>;

// Database layer interface
/*
type UserRepository = {
    create_user: async fn(req: CreateUserRequest) -> UserResult,
    get_user: async fn(id: UserId) -> UserResult,
    list_users: async fn(limit: int, offset: int) -> UsersResult,
    update_user: async fn(id: UserId, updates: UserUpdate) -> UserResult,
    delete_user: async fn(id: UserId) -> ApiResult<nothing>
}
*/

type PostgresUserRepository = {
    @shared db: Database
}

extern<PostgresUserRepository> {
    async fn create_user(self: &PostgresUserRepository, req: CreateUserRequest) -> UserResult {
        // Validation
        let validation_result: ApiResult<nothing> = validate_create_request(&req);
        compare validation_result {
            Ok(_) => {},
            Error(err) => return err
        };

        // Database query
        let query: string = "INSERT INTO users (name, email, profile, created_at) VALUES (?, ?, ?, NOW()) RETURNING *";
        let profile_json: string = JSON.stringify(req.profile);

        let result: QueryResult = await self.db.query(query, [req.name, req.email, profile_json]);

        return compare result {
            Ok(rows) => {
                let user_data = rows[0];
                Ok(User {
                    id: UserId(user_data.get_int("id")),
                    name: user_data.get_string("name"),
                    email: user_data.get_string("email"),
                    created_at: user_data.get_timestamp("created_at"),
                    profile: JSON.parse<UserProfile>(user_data.get_string("profile"))
                })
            },
            Error(db_err) => Error(DatabaseError {
                message: "Failed to create user",
                code: 500,
                query: query,
                details: db_err.to_string()
            })
        };
    }

    async fn get_user(self: &PostgresUserRepository, id: UserId) -> UserResult {
        let query: string = "SELECT * FROM users WHERE id = ?";
        let result: QueryResult = await self.db.query(query, [id.value()]);

        return compare result {
            Ok(rows) if rows.len() > 0 => {
                let user_data = rows[0];
                Ok(User {
                    id: id,
                    name: user_data.get_string("name"),
                    email: user_data.get_string("email"),
                    created_at: user_data.get_timestamp("created_at"),
                    profile: JSON.parse<UserProfile>(user_data.get_string("profile"))
                })
            },
            Ok(_) => Error(AppError {
                message: "User not found",
                code: 404
            }),
            Error(db_err) => Error(DatabaseError {
                message: "Database query failed",
                code: 500,
                query: query,
                details: db_err.to_string()
            })
        };
    }

    async fn list_users(self: &PostgresUserRepository, limit: int, offset: int) -> UsersResult {
        let query: string = "SELECT * FROM users ORDER BY created_at DESC LIMIT ? OFFSET ?";
        let result: QueryResult = await self.db.query(query, [limit, offset]);

        return compare result {
            Ok(rows) => {
                let mut users: User[] = [];
                for (let row in rows) {
                    let user: User = User {
                        id: UserId(row.get_int("id")),
                        name: row.get_string("name"),
                        email: row.get_string("email"),
                        created_at: row.get_timestamp("created_at"),
                        profile: JSON.parse<UserProfile>(row.get_string("profile"))
                    };
                    users = users + [user];
                }
                Ok(users)
            },
            Error(db_err) => Error(DatabaseError {
                message: "Failed to list users",
                code: 500,
                query: query,
                details: db_err.to_string()
            })
        };
    }

    // Additional methods...
}

// Service layer
type UserService = {
    @shared repository: PostgresUserRepository,
    @shared cache: HashMap<UserId, User>
}

extern<UserService> {
    async fn get_user_cached(self: &UserService, id: UserId) -> UserResult {
        // Check cache first
        let cached: Option<User> = self.cache.get(&id);
        compare cached {
            Some(user) => return Ok(user),
            nothing => {}
        };

        // Fetch from database
        let user_result: UserResult = await self.repository.get_user(id);
        compare user_result {
            Ok(user) => {
                self.cache.insert(id, user.clone());
                return Ok(user);
            },
            Error(err) => return Error(err)
        };
    }

    async fn create_user_with_notification(self: &UserService, req: CreateUserRequest) -> UserResult {
        let user_result: UserResult = await self.repository.create_user(req);

        compare user_result {
            Ok(user) => {
                // Send welcome email asynchronously
                spawn send_welcome_email(user.email);

                // Clear cache
                self.cache.clear();

                return Ok(user);
            },
            Error(err) => return Error(err)
        };
    }
}

// HTTP handlers
async fn handle_get_user(request: Request, state: &AppState) -> Response {
    let user_id_str: Option<string> = request.path_param("id");

    let user_id: UserId = compare user_id_str {
        Some(id_str) => {
            compare id_str.parse_int() {
                Some(id) => UserId(id),
                nothing => return Response::bad_request("Invalid user ID")
            }
        },
        nothing => return Response::bad_request("User ID required")
    };

    let service: UserService = UserService {
        repository: PostgresUserRepository { db: state.database.clone() },
        cache: state.user_cache.clone()
    };

    let result: UserResult = await service.get_user_cached(user_id);

    return compare result {
        Ok(user) => {
            let json: string = JSON.stringify(user);
            Response::ok(json).with_header("Content-Type", "application/json")
        },
        Error(AppError { code: 404, .. }) => Response::not_found("User not found"),
        Error(err) => Response::internal_error(err.message)
    };
}

async fn handle_create_user(request: Request, state: &AppState) -> Response {
    let body: string = request.body();
    let create_req: Option<CreateUserRequest> = JSON.parse<CreateUserRequest>(body);

    let req: CreateUserRequest = compare create_req {
        Some(r) => r,
        nothing => return Response::bad_request("Invalid JSON")
    };

    let service: UserService = UserService {
        repository: PostgresUserRepository { db: state.database.clone() },
        cache: state.user_cache.clone()
    };

    let result: UserResult = await service.create_user_with_notification(req);

    return compare result {
        Ok(user) => {
            let json: string = JSON.stringify(user);
            Response::created(json).with_header("Content-Type", "application/json")
        },
        Error(ValidationError { field, reason, .. }) => {
            let error_json: string = JSON.stringify({
                "error": "validation_failed",
                "field": field,
                "reason": reason
            });
            Response::bad_request(error_json)
        },
        Error(err) => Response::internal_error(err.message)
    };
}

// Middleware
/*
async fn logging_middleware(request: Request, next: fn(Request) -> async Response) -> Response {
    let start_time: Timestamp = get_current_time();

    let response: Response = await next(request);

    let duration: Duration = get_current_time() - start_time;
    println(format("HTTP {} {} {} {}ms",
                  request.method(),
                  request.path(),
                  response.status_code(),
                  duration.milliseconds()));

    return response;
}

async fn rate_limiting_middleware(request: Request, next: fn(Request) -> async Response) -> Response {
    let client_ip: string = request.client_ip();
    let rate_limit: bool = check_rate_limit(client_ip);

    return compare rate_limit {
        true => await next(request),
        false => Response::too_many_requests("Rate limit exceeded")
    };
}

*/
// Application setup
async fn create_app() -> ApiResult<Server> {
    // Database connection
    let db_config: DatabaseConfig = DatabaseConfig {
        host: "localhost",
        port: 5432,
        database: "user_app",
        username: "app_user",
        password: "secure_password"
    };

    let database: Database = await Database::connect(db_config)?;

    // Application state
    let state: AppState = AppState {
        database: database,
        user_cache: HashMap::new(),
        request_count: 0
    };

    // Create server
    let server: Server = Server::new("0.0.0.0", 8080)
        .with_state(state)
        .route("GET", "/users/:id", handle_get_user)
        .route("POST", "/users", handle_create_user)
        .route("GET", "/health", handle_health_check);

    return Ok(server);
}

// Main function
async fn main() -> int {
    let app_result: ApiResult<Server> = await create_app();

    let server: Server = compare app_result {
        Ok(s) => s,
        Error(err) => {
            eprintln("Failed to create app: " + err.message);
            return 1;
        }
    };

    println("Server starting on http://0.0.0.0:8080");

    let server_result: Result<nothing, ServerError> = await server.listen();

    return compare server_result {
        Ok(_) => 0,
        Error(err) => {
            eprintln("Server error: " + err.to_string());
            return 1;
        }
    };
}

// Helper functions
fn validate_create_request(req: &CreateUserRequest) -> ApiResult<nothing> {
    if (req.name.is_empty()) {
        return Error(ValidationError {
            message: "Validation failed",
            code: 400,
            field: "name",
            reason: "Name cannot be empty"
        });
    }

    if (!is_valid_email(&req.email)) {
        return Error(ValidationError {
            message: "Validation failed",
            code: 400,
            field: "email",
            reason: "Invalid email format"
        });
    }

    return Ok(());
}

fn is_valid_email(email: &string) -> bool {
    return email.contains("@") && email.contains(".");
}

async fn send_welcome_email(email: string) {
    // Email sending logic
    println("Sending welcome email to: " + email);
}

fn check_rate_limit(client_ip: string) -> bool {
    // Rate limiting logic
    return true; // Simplified
}

async fn handle_health_check(request: Request, state: &AppState) -> Response {
    let health_status = {
        "status": "healthy",
        "uptime": get_uptime(),
        "requests_served": atomic_load(&state.request_count)
    };

    return Response::ok(JSON.stringify(health_status))
        .with_header("Content-Type", "application/json");
}
