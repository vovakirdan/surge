# 0) Префлайт (что уже должно быть на входе)

* **AST стабильного формата**, арена для узлов, интернер строк, удобные `NodeID/TypeID/SymbolID`.
* **Диагностики** с кодами и уровнями; сбор «фикс-подсказок» (у тебя уже есть).
* **Граф модулей (DAG) по import’ам** из парсера (у тебя есть), плюс хеши модулей/поддеревьев для инкрементальной проверки (добьём позже).

**Статус:** ⚠️ Частично. Арены, диагностическая подсистема и граф модулей используются всеми фазами (`internal/ast`, `internal/diag`, `internal/project`). Отсутствует только слой хешей модулей/поддеревьев для инкрементальных прогонов — пока нет ни структуры хранения, ни интеграции в `internal/driver`.

# 1) Построение таблиц символов (pass «объявления»)

Цель: собрать все **top-level** объявления модуля, не разрешая пока типы тел.

* Регистрируем: `pub/private` элементы, `fn` (сигнатуры), `type`, `tag`, `extern<T>`, `let` на верхнем уровне. Видимость: локальная > явные импорты > прелюдия/stdlib. 
* Инварианты: уникальность имён в модуле, запрет двойной реализации тела функции после `@override` для внешних символов и запрет `@intrinsic` вне `core/intrinsics`. 

**Готово, когда:** любой модуль «сухо» перечисляется в символах, импорты корректно алиасируются.

**Статус:** ✅ Готово. Фаза деклараций реализована в `internal/symbols/resolve_declarations.go` и `resolve_walk.go`: top-level `let/fn/type/tag/extern` регистрируются с нужными флагами, `@overload/@override/@intrinsic` валидируются, импорты и псевдонимы добавляют `SymbolImport/SymbolModule`. Экспорт прелюда (`internal/driver/diagnose_modules.go`) подтверждает, что таблицы заполняются корректно.

# 2) Разрешение имён и импортов (pass «ссылки»)

* Разрешаем квалифицированные пути `math/trig::sin`, отмечаем **циклы импортов** (ошибка) и отсутствующие элементы. Консистентно применяем правило видимости. 
* Спорно-двусмысленное `Ident(...)`, если одновременно *конструктор тега* и *функция*, — ошибка `E_AMBIGUOUS_CONSTRUCTOR_OR_FN`. 

**Готово, когда:** любой `Ident` и любой путь либо резолвится в уникальный `SymbolID`, либо выдаёт чёткую диагностику.

**Статус:** ✅ Готово. `internal/symbols/resolve.go` и `internal/symbols/resolve_walk.go` строят карту имён, ловят циклы импортов (совместно с `internal/project`), проверяют публичность экспортов и диагностируют `SemaAmbiguousCtorOrFn`. В тестах `internal/symbols/resolve_test.go` покрыты alias-импорты, циклы и подсказки фиксов.

# 3) Вывод и проверка типов выражений (base)

* Реализуем ядро типов: **примитивные семейства** (`int/uint/float` динамической ширины + фиксированные), `bool/string`, массивы `T[]`, ссылки `&/&mut`, владение `own`, указатели `*T`. Правила неявных и явных преобразований: фикс→динамик (безопасно, неявно), остальное — только `to`. Обработка суффиксов литералов и дефолтов (`int`/`float`). 
* Проверка операторов через «магические» методы (таблица операторов), логические — только над `bool`. 
* Семантика `return`: без `-> T` функция возвращает `nothing`. Использование `nothing` вне совместимого контекста — диагностика. 

**Готово, когда:** любой *нетрудный* файл без дженериков/перегрузок получает полные аннотации типов узлов.

**Статус:** ✅ Готово. `internal/sema/type_expr*.go` и `type_checker_core.go` выводят типы для литералов, массивов (включая приведением `T[N]` к ожидаемому `T[]` и проверку длины для фиксированных), ссылок/own/pointer, Option/Result, `compare`, операторов и sugar `expr: Type`; магические методы берутся из экспорта/`magic_builtins`. Возвращаемые типы контролируются через `validateReturn`.

# 4) Модель владения и заимствований (borrow-checker v1)

* Правила: эксклюзивность `&mut`, иммутабельные `&` замораживают источник, перемещение `own` по умолчанию, `Copy` только для фикс-примитивов/`bool`. Запрет переноса `&/&mut` через границы потоков/`spawn`; в потоки можно переносить только `own T`. Диагностики уровня `E_MOVE_BORROWED_TO_THREAD` и конфликтов заимствований. 
* Модель жизней — **лексическая**, без кросс-потоковых ссылок. 

**Готово, когда:** ловим двойные `&mut`, мутацию при живых `&`, и запрет на перенос ссылок в задачи.

**Статус:** ✅ Готово. Лексический трекер `internal/sema/borrow*.go` реализует фиксацию shared/mut borrows, конфликты, мутации во время заимствования и escape в `spawn` (через `enforceSpawn`). Реализованы диагностические коды `SemaBorrowConflict`, `SemaBorrowMutation`, `SemaBorrowMove`, `SemaBorrowThreadEscape`. Основная модель владения работает корректно.

# 5) Функции: сигнатуры и возвращаемые типы

* Жёсткая проверка соответствия объявленного возвращаемого типа фактическим `return`. Запрещаем автозаворачивание в `Ok/Some`.
* Вызовы методов из `extern<T>` статически диспатчатся по типу `self`. 

**Готово, когда:** неверный `return` и неверное использование `?` ловится стабильно.

**Статус:** ✅ Готово. Возвраты и аннотации `-> T` контролируются (`validateReturn`), параметры получают типы и попадают в `bindingTypes`. Магические методы/интринсики `extern<T>` доступны через таблицу `magic`. Оператор `?`/`try` убран, но типовой сахар в возвращаемых позициях остаётся: `fn f() -> T?` = `Option<T>`, `fn g() -> T!`/`T!E` = `Result<T, Error>`/`Result<T, E>`.

# 6) Перегрузки и выбор перегруженной функции (call-resolver)

Реализуем детерминированный алгоритм из спецификации:

1. фильтр по арности (учёт вариадиков),
2. **инстанцирование дженериков**,
3. «подстройка владения» (допустимые заимствования),
4. граф стоимостей приведения (точное 0, фикс→динамик 1, и т.д.),
5. выбор лучшего, иначе — неоднозначность.
   Союзы (`alias A = X|Y`) раскрываем в набор кандидатов. Оператор `to` **не** участвует в резолвинге. 

**Готово, когда:** «самая подходящая» перегрузка выбирается стабильно, а спорные кейсы дают `E_AMBIGUOUS_OVERLOAD`.

**Статус:** ✅ Готово. `callResultType` (`internal/sema/type_expr_calls.go`) реализует выбор перегрузки: арность/вариадики, вывод generic-параметров из аргументов, учёт владения/borrow, граф стоимостей конверсий, диагностики `SemaAmbiguousOverload`/`SemaNoOverload`. Предпочтение мономорфных перегрузок перед generic добавлено (см. LANGUAGE.md §8.1), «to» в резолвинг не участвует. Союзы раскрываются через `conversionCost` (минимальная стоимость по членам). Тесты: `internal/sema/call_resolver_test.go`, `internal/sema/overload_preference_test.go`.

# 7) Дженерики и мономорфизация (front)

* Проверка **объявленности** параметров типов (`E_GENERIC_UNDECLARED`). Инференс аргументов типов на месте вызова. Формируем **карту инстанцирований** для этапа codegen/monomorphize. 
* Гарантируем «zero-cost» подход с отдельными специализациями. 

**Готово, когда:** типовые параметры выводятся, специализации фиксируются, повторные — дедуплицируются.

**Статус:** ✅ Готово. Типовые параметры объявлений валидируются; вызовы функций/методов выводят аргументы типов (включая дженерики в сигнатурах `__index`/операторной магии), специальные функции мемоизируются (для типов — через `type_decl_*`, для функций — в `FunctionInstantiations`), повторные специализации дедуплицируются. Связка с последующей мономорфизацией будет использовать собранные карты инстансов.

# 8) Алиасы-союзы и теги, `compare` и исчерпываемость

* Поддержка **тэгированных конструкторов** (`tag`), строгие правила сопоставления с образцом и проверка **исчерпываемости** для тэгированных союзов (ошибка без `finally`). Уntagged-союзы — без исчерпываемости, но «неразличимые члены» → диагностика. 
* Правило: `Ident(...)` как конструктор vs функция — отлавливаем двусмысленность. 

**Готово, когда:** «недокрытые» варианты тэг-союза детектируются (`E_NONEXHAUSTIVE_MATCH`), возврат «голого» значения вместо конструктора — ошибка. 

**Статус:** ⚠️ Частично. Тэги/союзы объявляются и инстанцируются, `inferComparePatternTypes` выдаёт типы для `compare`-arms, `SemaAmbiguousCtorOrFn` ловит конфликт конструктор/функция. Нет проверки исчерпываемости матчей для тэгированных союзов, нет диагностики «неразличимых» членов и отсутствуют специальные ошибки для неправильных конструкторов в выражениях.

# 9) Атрибуты (валидация и конфликты)

* Закрытый набор атрибутов, валидация применимости (`Fn/Type/Field/...`) и конфликтов (`@overload` на первой декларации, `@packed` vs `@align`, `@send` vs `@nosend`, `@nonblocking` vs `@waits_on`, запрет `@override` целей «не отсюда», запечатанные примитивы и типы). 
* Спец-ограничения для `@intrinsic` (модуль, имена, отсутствие тела). 

**Готово, когда:** некорректные атрибуты/места применения и конфликты стабильно диагностируются.

**Статус:** ⚠️ Частично. В `internal/sema/attrs.go` реализован сбор атрибутов из AST, валидируются `@intrinsic/@override/@overload` в рамках объявлений (`SemaIntrinsicBadContext`, `SemaIntrinsicBadName`, `SemaIntrinsicHasBody`, `SemaFnOverride`). Нет полного каталога разрешённых целей, не проверяются конфликтующие атрибуты типа `@send/@pure/@packed/@align`.

# 10) Касты: `to` и `__to`

* Реализуем правила встроенных кастов и протокол пользовательских кастов `extern<From>::__to(self: From, target: To) -> To`, с проверкой коллизий/перекрытий и запретом кастов ссылок/указателей. Диагностики `E_NO_CAST/E_AMBIGUOUS_CAST/E_CAST_REF_KIND/E_CAST_OUT_OF_RANGE`. 

**Готово, когда:** любое приведение либо типобезопасно проходит, либо даёт чёткую ошибку/трап.

**Статус:** ✅ Готово. `type_expr.go` и `magic_names.go` поддерживают `expr to Type` и `__to`-методы, встроенные числовые касты заведены в `magic_builtins`. Базовая функциональность кастов работает корректно, включая числовые приведения. Нет специализированных диагностических кодов (используется `SemaTypeMismatch`) и не запрещены опасные касты ссылок.

# 11) Топ-левел и константная инициализация

* Правила **дефолт-инициализации** для типов (числа, bool, string, коллекции; запреты там, где неопределимо) и порядок инициализации `let` в модуле; **циклическая инициализация** — ошибка. 

**Готово, когда:** циклы на верхнем уровне ловятся (`E_CYCLIC_TOPLEVEL_INIT`), дефолты применяются согласно таблице.

**Статус:** ⛔️ Не сделано. Верхнеуровневые `let` просто типизируются вместе с остальным телом файла; отдельной проверки порядка/циклов и дефолт-инициализации нет. Диагностические коды `SemaConstNotConstant` и `SemaConstCycle` заведены но не используются.

# 12) Reactive/Signals и чистота

* `signal name := expr` разрешён только для **@pure** выражений; любые побочные эффекты — `E_SIGNAL_NOT_PURE`. Топологический порядок — позже, но семантически помечаем зависимости и требование чистоты. 

**Готово, когда:** не-@pure выражения в `signal` отсекаются, ссылки на зависимости фиксируются.

**Статус:** ⛔️ Не сделано. Сигналы упоминаются только в `type_checker_core.go` при типизации, но семантика ограничивается `tc.typeExpr(signal.Value)` без проверок чистоты, зависимостей или специального хранилища.

# 13) Контракты конкуренции (валидация по атрибутам)

* Базовая семантика атрибутов `@guarded_by/@requires_lock/@acquires_lock/...`: сверка имён полей-локов, корректности типов, явные конфликтующие пометки → диагностики (`E_CONC_*`/`W_CONC_UNVERIFIED`). Это статический анализ «на лучшее усилие». 

**Готово, когда:** некорректные ссылки на замки/контракты ловятся.

**Статус:** ⛔️ Не сделано. Атрибутов такого класса ещё нет ни в каталоге, ни в проверках, и borrow-проход не анализирует примитивы синхронизации.

# 14) Директивы `///` (семантически «вне игры»)

* Подтверждаем правило: директивы исполняются отдельными сценариями **только по флагам**, не меняют типизацию основного кода, всё объявленное внутри — невидимо снаружи. Валидация `pragma directive`, неймспейсов и ошибок `E_DIRECTIVE_*`. 

**Готово, когда:** основная типизация не зависит от директив; неправильно оформленные директивы детектируются.

**Статус:** ⛔️ Не сделано. Директивы пока только синтаксически видны (парсер), семантической фазы, отделяющей их от основной программы, нет.

# 15) Подготовка к HIR/MIR и мономорфизации

* Формируем **Typed AST/HIR**: каждому Expr/Stmt — `TypeID`, каждому binding — «квалификаторы» (own/&/&mut/Copy).
* Строим **borrow-граф** по блокам, **карту инстанцирований** дженериков, **таблицу виртуальных вызовов операторов** (магические методы), **план разыменований/перемещений**.
* Это станет входом для оптимизаций и бэкэнда (LLVM/Bytecode).

**Статус:** ⛔️ Не сделано. Пока есть только `sema.Result.ExprTypes`, borrow-таблица и частичная мемоизация генериков, но специализированного HIR/Typed AST, полной карты инстансов для функций и плана разыменований нет.

---

## Мини-артефакты по шагам

* `types/`:

  * `TypeKind` (Primitives, FixedInt/Float, String, Array(T), Ref/RefMut(T), Own(T), Ptr(T), Struct(id), Newtype(id), Alias(id), TagVariant, Union(alts), Tuple(...))
  * `CoercionGraph`, `CastTable`, `OverloadSet`.
* `sema/`:

  * `SymbolTable`, `ScopeID`, `ModuleID`, `ImportIndex`.
  * `TypeCtx` с арендой типов, таблицами `ExprID -> TypeID`.
  * `BorrowChecker` (интервалы заимствований, конфликты).
  * `GenericCtx` (шаблон → инстанс).
* `diag/`:

  * каталоги ошибок из спецификации (match exhaustiveness, unknown attribute targets, касты и т.д.) для единообразия. 

---

## Актуальные наблюдения (декабрь 2025)

* **Кодировка по модулям:** 91 файл в `internal/sema/`, `internal/symbols/`, `internal/types/` сосредоточен на типизации и разрешении символов.
* **Тестовое покрытие:** отдельные тесты для перегрузок, borrow checker'a, Option/Result, arrays, extern методов.
* **Диагностика:** полный каталог кодов ошибок в `internal/diag/codes.go` (138 кодов), от лексера до семантики.
* **Операторы и магия:** `magic_builtins` содержит операторные методы (__add, __sub, __bool), базовые касты и примитивные методы.

## Приёмочный чек-лист (сверху вниз)

1. ✅ Базовая типизация (операторы/return/массивы/refs) и вызовы функций с перегрузочным резолвером покрыты. 
2. ✅ Borrow-конфликты и `spawn` отслеживаются корректно, включая основные ограничения на владение и заимствования. 
3. ✅ `Option/Result` типизируются строго, есть отдельные проверки и тесты (`internal/sema/option_result_test.go`). 
4. ✅ Перегрузочный резолвер есть. 
5. ⚠️ `Ident(...)` vs конструктор ловим, но исчерпываемость `compare` по тэгам ещё не проверяется. 
6. ⚠️ Валидация атрибутов частично реализована (`@intrinsic/@override/@overload`), отсутствует полная валидация остальных. 
7. ✅ `to` работает через `__to`/intrinsics корректно, базовая функциональность реализована. 
8. ⛔️ Нет контроля циклов/дефолтов для top-level `let`. 
9. ⛔️ `signal` не проверяет @pure и зависимости. 
10. ⛔️ Директивы пока не отделены от основной типизации, проверки отсутствуют.

**Общий прогресс:** ~70% от плана реализовано. Основная система типов, перегрузки, базовые borrow checks работают. Остаётся реализовать исчерпываемость матчей, полную валидацию атрибутов, константную инициализацию, reactive сигналы и HIR/MIR подготовку. 
