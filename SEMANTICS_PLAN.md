# 0) Префлайт (что уже должно быть на входе)

* **AST стабильного формата**, арена для узлов, интернер строк, удобные `NodeID/TypeID/SymbolID`.
* **Диагностики** с кодами и уровнями; сбор «фикс-подсказок» (у тебя уже есть).
* **Граф модулей (DAG) по import’ам** из парсера (у тебя есть), плюс хеши модулей/поддеревьев для инкрементальной проверки (добьём позже).

# 1) Построение таблиц символов (pass «объявления»)

Цель: собрать все **top-level** объявления модуля, не разрешая пока типы тел.

* Регистрируем: `pub/private` элементы, `fn` (сигнатуры), `type`, `tag`, `extern<T>`, `let` на верхнем уровне. Видимость: локальная > явные импорты > прелюдия/stdlib. 
* Инварианты: уникальность имён в модуле, запрет двойной реализации тела функции после `@override` для внешних символов и запрет `@intrinsic` вне `core/intrinsics`. 

**Готово, когда:** любой модуль «сухо» перечисляется в символах, импорты корректно алиасируются.

# 2) Разрешение имён и импортов (pass «ссылки»)

* Разрешаем квалифицированные пути `math/trig::sin`, отмечаем **циклы импортов** (ошибка) и отсутствующие элементы. Консистентно применяем правило видимости. 
* Спорно-двусмысленное `Ident(...)`, если одновременно *конструктор тега* и *функция*, — ошибка `E_AMBIGUOUS_CONSTRUCTOR_OR_FN`. 

**Готово, когда:** любой `Ident` и любой путь либо резолвится в уникальный `SymbolID`, либо выдаёт чёткую диагностику.

# 3) Вывод и проверка типов выражений (base)

* Реализуем ядро типов: **примитивные семейства** (`int/uint/float` динамической ширины + фиксированные), `bool/string`, массивы `T[]`, ссылки `&/&mut`, владение `own`, указатели `*T`. Правила неявных и явных преобразований: фикс→динамик (безопасно, неявно), остальное — только `to`. Обработка суффиксов литералов и дефолтов (`int`/`float`). 
* Проверка операторов через «магические» методы (таблица операторов), логические — только над `bool`. 
* Семантика `return`: без `-> T` функция возвращает `nothing`. Использование `nothing` вне совместимого контекста — диагностика. 

**Готово, когда:** любой *нетрудный* файл без дженериков/перегрузок получает полные аннотации типов узлов.

# 4) Модель владения и заимствований (borrow-checker v1)

* Правила: эксклюзивность `&mut`, иммутабельные `&` замораживают источник, перемещение `own` по умолчанию, `Copy` только для фикс-примитивов/`bool`. Запрет переноса `&/&mut` через границы потоков/`spawn`; в потоки можно переносить только `own T`. Диагностики уровня `E_MOVE_BORROWED_TO_THREAD` и конфликтов заимствований. 
* Модель жизней — **лексическая**, без кросс-потоковых ссылок. 

**Готово, когда:** ловим двойные `&mut`, мутацию при живых `&`, и запрет на перенос ссылок в задачи.

# 5) Функции: сигнатуры, возвращаемые типы, `?`

* Жёсткая проверка соответствия возвращаемого типа; **оператор `?`** разрешён только для `Result<T,E>` и правильно «пробрасывает» `Error(E)`. Запрещаем автозаворачивание в `Ok/Some`. 
* Вызовы методов из `extern<T>` статически диспатчатся по типу `self`. 

**Готово, когда:** неверный `return` и неверное использование `?` ловится стабильно.

# 6) Перегрузки и выбор перегруженной функции (call-resolver)

Реализуем детерминированный алгоритм из спецификации:

1. фильтр по арности (учёт вариадиков),
2. **инстанцирование дженериков**,
3. «подстройка владения» (допустимые заимствования),
4. граф стоимостей приведения (точное 0, фикс→динамик 1, и т.д.),
5. выбор лучшего, иначе — неоднозначность.
   Союзы (`alias A = X|Y`) раскрываем в набор кандидатов. Оператор `to` **не** участвует в резолвинге. 

**Готово, когда:** «самая подходящая» перегрузка выбирается стабильно, а спорные кейсы дают `E_AMBIGUOUS_OVERLOAD`.

# 7) Дженерики и мономорфизация (front)

* Проверка **объявленности** параметров типов (`E_GENERIC_UNDECLARED`). Инференс аргументов типов на месте вызова. Формируем **карту инстанцирований** для этапа codegen/monomorphize. 
* Гарантируем «zero-cost» подход с отдельными специализациями. 

**Готово, когда:** типовые параметры выводятся, специализации фиксируются, повторные — дедуплицируются.

# 8) Алиасы-союзы и теги, `compare` и исчерпываемость

* Поддержка **тэгированных конструкторов** (`tag`), строгие правила сопоставления с образцом и проверка **исчерпываемости** для тэгированных союзов (ошибка без `finally`). Уntagged-союзы — без исчерпываемости, но «неразличимые члены» → диагностика. 
* Правило: `Ident(...)` как конструктор vs функция — отлавливаем двусмысленность. 

**Готово, когда:** «недокрытые» варианты тэг-союза детектируются (`E_NONEXHAUSTIVE_MATCH`), возврат «голого» значения вместо конструктора — ошибка. 

# 9) Атрибуты (валидация и конфликты)

* Закрытый набор атрибутов, валидация применимости (`Fn/Type/Field/...`) и конфликтов (`@overload` на первой декларации, `@packed` vs `@align`, `@send` vs `@nosend`, `@nonblocking` vs `@waits_on`, запрет `@override` целей «не отсюда», запечатанные примитивы и типы). 
* Спец-ограничения для `@intrinsic` (модуль, имена, отсутствие тела). 

**Готово, когда:** некорректные атрибуты/места применения и конфликты стабильно диагностируются.

# 10) Касты: `to` и `__cast`

* Реализуем правила встроенных кастов и протокол пользовательских кастов `extern<From>::__cast<To>`, с проверкой коллизий/перекрытий и запретом кастов ссылок/указателей. Диагностики `E_NO_CAST/E_AMBIGUOUS_CAST/E_CAST_REF_KIND/E_CAST_OUT_OF_RANGE`. 

**Готово, когда:** любое приведение либо типобезопасно проходит, либо даёт чёткую ошибку/трап.

# 11) Топ-левел и константная инициализация

* Правила **дефолт-инициализации** для типов (числа, bool, string, коллекции; запреты там, где неопределимо) и порядок инициализации `let` в модуле; **циклическая инициализация** — ошибка. 

**Готово, когда:** циклы на верхнем уровне ловятся (`E_CYCLIC_TOPLEVEL_INIT`), дефолты применяются согласно таблице.

# 12) Reactive/Signals и чистота

* `signal name := expr` разрешён только для **@pure** выражений; любые побочные эффекты — `E_SIGNAL_NOT_PURE`. Топологический порядок — позже, но семантически помечаем зависимости и требование чистоты. 

**Готово, когда:** не-@pure выражения в `signal` отсекаются, ссылки на зависимости фиксируются.

# 13) Контракты конкуренции (валидация по атрибутам)

* Базовая семантика атрибутов `@guarded_by/@requires_lock/@acquires_lock/...`: сверка имён полей-локов, корректности типов, явные конфликтующие пометки → диагностики (`E_CONC_*`/`W_CONC_UNVERIFIED`). Это статический анализ «на лучшее усилие». 

**Готово, когда:** некорректные ссылки на замки/контракты ловятся.

# 14) Директивы `///` (семантически «вне игры»)

* Подтверждаем правило: директивы исполняются отдельными сценариями **только по флагам**, не меняют типизацию основного кода, всё объявленное внутри — невидимо снаружи. Валидация `pragma directive`, неймспейсов и ошибок `E_DIRECTIVE_*`. 

**Готово, когда:** основная типизация не зависит от директив; неправильно оформленные директивы детектируются.

# 15) Подготовка к HIR/MIR и мономорфизации

* Формируем **Typed AST/HIR**: каждому Expr/Stmt — `TypeID`, каждому binding — «квалификаторы» (own/&/&mut/Copy).
* Строим **borrow-граф** по блокам, **карту инстанцирований** дженериков, **таблицу виртуальных вызовов операторов** (магические методы), **план разыменований/перемещений**.
* Это станет входом для оптимизаций и бэкэнда (LLVM/Bytecode).

---

## Мини-артефакты по шагам

* `types/`:

  * `TypeKind` (Primitives, FixedInt/Float, String, Array(T), Ref/RefMut(T), Own(T), Ptr(T), Struct(id), Newtype(id), Alias(id), TagVariant, Union(alts), Tuple(...))
  * `CoercionGraph`, `CastTable`, `OverloadSet`.
* `sema/`:

  * `SymbolTable`, `ScopeID`, `ModuleID`, `ImportIndex`.
  * `TypeCtx` с арендой типов, таблицами `ExprID -> TypeID`.
  * `BorrowChecker` (интервалы заимствований, конфликты).
  * `GenericCtx` (шаблон → инстанс).
* `diag/`:

  * каталоги ошибок из спецификации (match exhaustiveness, unknown attribute targets, касты и т.д.) для единообразия. 

---

## Приёмочный чек-лист (сверху вниз)

1. Любой модуль без дженериков/перегрузок типизируется: операторы, `return`, массивы, ссылки, `own`. 
2. Borrow-ошибки и переносы через `spawn` ловятся. 
3. `Result/Option` работают строго, `?` корректно коротит. 
4. Перегрузки/вариадики/союзы выбираются детерминированно (алгоритм §8). 
5. `compare` по тэг-союзам проверяется на исчерпываемость; двусмысленный `Ident(...)` — ошибка. 
6. Атрибуты валидируются, конфликты/запреты — диагностируются. 
7. Касты `to` и `__cast` проверены, ошибки по списку. 
8. Топ-левел `let` — без циклов, дефолты типов соблюдены. 
9. `signal` требует @pure, зависимости зафиксированы. 
10. Директивы не влияют на типизацию программы; неправильные — диагностируются. 
