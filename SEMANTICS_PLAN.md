# 0) Префлайт (что уже должно быть на входе)

* **AST стабильного формата**, арена для узлов, интернер строк, удобные `NodeID/TypeID/SymbolID`.
* **Диагностики** с кодами и уровнями; сбор «фикс-подсказок» (у тебя уже есть).
* **Граф модулей (DAG) по import’ам** из парсера (у тебя есть), плюс хеши модулей/поддеревьев для инкрементальной проверки (добьём позже).

**Статус:** ⚠️ Частично. Арены, диагностическая подсистема и граф модулей используются всеми фазами (`internal/ast`, `internal/diag`, `internal/project`). Отсутствует только слой хешей модулей/поддеревьев для инкрементальных прогонов — пока нет ни структуры хранения, ни интеграции в `internal/driver`.

# 1) Построение таблиц символов (pass «объявления»)

Цель: собрать все **top-level** объявления модуля, не разрешая пока типы тел.

* Регистрируем: `pub/private` элементы, `fn` (сигнатуры), `type`, `tag`, `extern<T>`, `let` на верхнем уровне. Видимость: локальная > явные импорты > прелюдия/stdlib. 
* Инварианты: уникальность имён в модуле, запрет двойной реализации тела функции после `@override` для внешних символов и запрет `@intrinsic` вне `core/intrinsics`. 

**Готово, когда:** любой модуль «сухо» перечисляется в символах, импорты корректно алиасируются.

**Статус:** ✅ Готово. Фаза деклараций реализована в `internal/symbols/resolve_declarations.go` и `resolve_walk.go`: top-level `let/fn/type/tag/extern` регистрируются с нужными флагами, `@overload/@override/@intrinsic` валидируются, импорты и псевдонимы добавляют `SymbolImport/SymbolModule`. Экспорт прелюда (`internal/driver/diagnose_modules.go`) подтверждает, что таблицы заполняются корректно.

# 2) Разрешение имён и импортов (pass «ссылки»)

* Разрешаем квалифицированные пути `math/trig::sin`, отмечаем **циклы импортов** (ошибка) и отсутствующие элементы. Консистентно применяем правило видимости. 
* Спорно-двусмысленное `Ident(...)`, если одновременно *конструктор тега* и *функция*, — ошибка `E_AMBIGUOUS_CONSTRUCTOR_OR_FN`. 

**Готово, когда:** любой `Ident` и любой путь либо резолвится в уникальный `SymbolID`, либо выдаёт чёткую диагностику.

**Статус:** ✅ Готово. `internal/symbols/resolve.go` и `internal/symbols/resolve_walk.go` строят карту имён, ловят циклы импортов (совместно с `internal/project`), проверяют публичность экспортов и диагностируют `SemaAmbiguousCtorOrFn`. В тестах `internal/symbols/resolve_test.go` покрыты alias-импорты, циклы и подсказки фиксов.

# 3) Вывод и проверка типов выражений (base)

* Реализуем ядро типов: **примитивные семейства** (`int/uint/float` динамической ширины + фиксированные), `bool/string`, массивы `T[]`, ссылки `&/&mut`, владение `own`, указатели `*T`. Правила неявных и явных преобразований: фикс→динамик (безопасно, неявно), остальное — только `to`. Обработка суффиксов литералов и дефолтов (`int`/`float`). 
* Проверка операторов через «магические» методы (таблица операторов), логические — только над `bool`. 
* Семантика `return`: без `-> T` функция возвращает `nothing`. Использование `nothing` вне совместимого контекста — диагностика. 

**Готово, когда:** любой *нетрудный* файл без дженериков/перегрузок получает полные аннотации типов узлов.

**Статус:** ⚠️ Частично. `internal/sema/type_expr*.go` и `type_checker_core.go` уже выводят типы для литералов, массивов, ссылок/own/pointer, Option/Result, `compare`, операторов и sugar `expr: Type`; магические методы берутся из экспорта/`magic_builtins`. Возвращаемые типы контролируются через `validateReturn`. Пока нет implicit fixed→dynamic coercions (`typesAssignable` проверяет только равенство); остальное покрывается call-resolver (#6).

# 4) Модель владения и заимствований (borrow-checker v1)

* Правила: эксклюзивность `&mut`, иммутабельные `&` замораживают источник, перемещение `own` по умолчанию, `Copy` только для фикс-примитивов/`bool`. Запрет переноса `&/&mut` через границы потоков/`spawn`; в потоки можно переносить только `own T`. Диагностики уровня `E_MOVE_BORROWED_TO_THREAD` и конфликтов заимствований. 
* Модель жизней — **лексическая**, без кросс-потоковых ссылок. 

**Готово, когда:** ловим двойные `&mut`, мутацию при живых `&`, и запрет на перенос ссылок в задачи.

**Статус:** ⚠️ Частично. Лексический трекер `internal/sema/borrow*.go` реализует фиксацию shared/mut borrows, конфликты, мутации во время заимствования и escape в `spawn` (через `enforceSpawn`). Не хватает классификации copy-тем (все перемещения считаются полноценными move), отсутствует учёт дропов/переносов в CFG и ограничения на перенос `&/&mut` между потоками за пределами `spawn`.

# 5) Функции: сигнатуры и возвращаемые типы

* Жёсткая проверка соответствия объявленного возвращаемого типа фактическим `return`. Запрещаем автозаворачивание в `Ok/Some`.
* Вызовы методов из `extern<T>` статически диспатчатся по типу `self`. 

**Готово, когда:** неверный `return` и неверное использование `?` ловится стабильно.

**Статус:** ⚠️ Частично. Возвраты и аннотации `-> T` контролируются (`validateReturn`), параметры получают типы и попадают в `bindingTypes`. Магические методы/интринсики `extern<T>` доступны через таблицу `magic`. Пока нет поддержки `?`/`try`-сахара и статического диспатча общих `extern` наборов вне магических методов.

# 6) Перегрузки и выбор перегруженной функции (call-resolver)

Реализуем детерминированный алгоритм из спецификации:

1. фильтр по арности (учёт вариадиков),
2. **инстанцирование дженериков**,
3. «подстройка владения» (допустимые заимствования),
4. граф стоимостей приведения (точное 0, фикс→динамик 1, и т.д.),
5. выбор лучшего, иначе — неоднозначность.
   Союзы (`alias A = X|Y`) раскрываем в набор кандидатов. Оператор `to` **не** участвует в резолвинге. 

**Готово, когда:** «самая подходящая» перегрузка выбирается стабильно, а спорные кейсы дают `E_AMBIGUOUS_OVERLOAD`.

**Статус:** ✅ Готово. `callResultType` (`internal/sema/type_expr_calls.go`) реализует выбор перегрузки: арность/вариадики, вывод generic-параметров из аргументов, учёт владения/borrow, граф стоимостей конверсий, диагностики `SemaAmbiguousOverload`/`SemaNoOverload`. Предпочтение мономорфных перегрузок перед generic добавлено (см. LANGUAGE.md §8.1), «to» в резолвинг не участвует. Союзы раскрываются через `conversionCost` (минимальная стоимость по членам). Тесты: `internal/sema/call_resolver_test.go`, `internal/sema/overload_preference_test.go`.

# 7) Дженерики и мономорфизация (front)

* Проверка **объявленности** параметров типов (`E_GENERIC_UNDECLARED`). Инференс аргументов типов на месте вызова. Формируем **карту инстанцирований** для этапа codegen/monomorphize. 
* Гарантируем «zero-cost» подход с отдельными специализациями. 

**Готово, когда:** типовые параметры выводятся, специализации фиксируются, повторные — дедуплицируются.

**Статус:** ⚠️ Частично. Арена типов уже умеет регистрировать обобщённые struct/alias/union и мемоизировать инстансы (`type_decl_*.go`, `type_decl_instantiate.go`). Нет инференса аргументов функций/методов, нет карты специализаций для вызовов и отсутствует связь с будущей мономорфизацией HIR.

# 8) Алиасы-союзы и теги, `compare` и исчерпываемость

* Поддержка **тэгированных конструкторов** (`tag`), строгие правила сопоставления с образцом и проверка **исчерпываемости** для тэгированных союзов (ошибка без `finally`). Уntagged-союзы — без исчерпываемости, но «неразличимые члены» → диагностика. 
* Правило: `Ident(...)` как конструктор vs функция — отлавливаем двусмысленность. 

**Готово, когда:** «недокрытые» варианты тэг-союза детектируются (`E_NONEXHAUSTIVE_MATCH`), возврат «голого» значения вместо конструктора — ошибка. 

**Статус:** ⚠️ Частично. Тэги/союзы объявляются и инстанцируются, `inferComparePatternTypes` выдаёт типы для `compare`-arms, `SemaAmbiguousCtorOrFn` ловит конфликт конструктор/функция. Нет проверки исчерпываемости матчей, нет диагностики «неразличимых» членов и отсутствуют специальные ошибки для неправильных конструкторов в выражениях.

# 9) Атрибуты (валидация и конфликты)

* Закрытый набор атрибутов, валидация применимости (`Fn/Type/Field/...`) и конфликтов (`@overload` на первой декларации, `@packed` vs `@align`, `@send` vs `@nosend`, `@nonblocking` vs `@waits_on`, запрет `@override` целей «не отсюда», запечатанные примитивы и типы). 
* Спец-ограничения для `@intrinsic` (модуль, имена, отсутствие тела). 

**Готово, когда:** некорректные атрибуты/места применения и конфликты стабильно диагностируются.

**Статус:** ⛔️ Не сделано. Сейчас валидируются только `@intrinsic/@override/@overload` в рамках объявлений. Нету каталога разрешённых целей, не проверяются конфликтующие атрибуты, `@send/@pure` и т.п. никак не учитываются.

# 10) Касты: `to` и `__to`

* Реализуем правила встроенных кастов и протокол пользовательских кастов `extern<From>::__to(self: From, target: To) -> To`, с проверкой коллизий/перекрытий и запретом кастов ссылок/указателей. Диагностики `E_NO_CAST/E_AMBIGUOUS_CAST/E_CAST_REF_KIND/E_CAST_OUT_OF_RANGE`. 

**Готово, когда:** любое приведение либо типобезопасно проходит, либо даёт чёткую ошибку/трап.

**Статус:** ⚠️ Частично. `type_expr.go` и `magic_names.go` поддерживают `expr to Type` и `__to`-методы, встроенные числовые касты заведены в `magic_builtins`. Но нет проверки конфликтов, отсутствуют специализированные диагностические коды (`пока используем SemaTypeMismatch`), не запрещены опасные касты ссылок/указателей.

# 11) Топ-левел и константная инициализация

* Правила **дефолт-инициализации** для типов (числа, bool, string, коллекции; запреты там, где неопределимо) и порядок инициализации `let` в модуле; **циклическая инициализация** — ошибка. 

**Готово, когда:** циклы на верхнем уровне ловятся (`E_CYCLIC_TOPLEVEL_INIT`), дефолты применяются согласно таблице.

**Статус:** ⛔️ Не сделано. Верхнеуровневые `let` просто типизируются вместе с остальным телом файла; отдельной проверки порядка/циклов и дефолт-инициализации нет.

# 12) Reactive/Signals и чистота

* `signal name := expr` разрешён только для **@pure** выражений; любые побочные эффекты — `E_SIGNAL_NOT_PURE`. Топологический порядок — позже, но семантически помечаем зависимости и требование чистоты. 

**Готово, когда:** не-@pure выражения в `signal` отсекаются, ссылки на зависимости фиксируются.

**Статус:** ⛔️ Не сделано. Сигналы разбираются парсером, но семантика ограничивается `tc.typeExpr(signal.Value)` без проверок чистоты, зависимостей или специального хранилища.

# 13) Контракты конкуренции (валидация по атрибутам)

* Базовая семантика атрибутов `@guarded_by/@requires_lock/@acquires_lock/...`: сверка имён полей-локов, корректности типов, явные конфликтующие пометки → диагностики (`E_CONC_*`/`W_CONC_UNVERIFIED`). Это статический анализ «на лучшее усилие». 

**Готово, когда:** некорректные ссылки на замки/контракты ловятся.

**Статус:** ⛔️ Не сделано. Атрибутов такого класса ещё нет ни в каталоге, ни в проверках, и borrow-проход не анализирует примитивы синхронизации.

# 14) Директивы `///` (семантически «вне игры»)

* Подтверждаем правило: директивы исполняются отдельными сценариями **только по флагам**, не меняют типизацию основного кода, всё объявленное внутри — невидимо снаружи. Валидация `pragma directive`, неймспейсов и ошибок `E_DIRECTIVE_*`. 

**Готово, когда:** основная типизация не зависит от директив; неправильно оформленные директивы детектируются.

**Статус:** ⛔️ Не сделано. Директивы пока только синтаксически видны (парсер), семантической фазы, отделяющей их от основной программы, нет.

# 15) Подготовка к HIR/MIR и мономорфизации

* Формируем **Typed AST/HIR**: каждому Expr/Stmt — `TypeID`, каждому binding — «квалификаторы» (own/&/&mut/Copy).
* Строим **borrow-граф** по блокам, **карту инстанцирований** дженериков, **таблицу виртуальных вызовов операторов** (магические методы), **план разыменований/перемещений**.
* Это станет входом для оптимизаций и бэкэнда (LLVM/Bytecode).

**Статус:** ⛔️ Не сделано. Пока есть только `sema.Result.ExprTypes` и borrow-таблица, но специализированного HIR/Typed AST, карты инстансов для функций и плана разыменований нет.

---

## Мини-артефакты по шагам

* `types/`:

  * `TypeKind` (Primitives, FixedInt/Float, String, Array(T), Ref/RefMut(T), Own(T), Ptr(T), Struct(id), Newtype(id), Alias(id), TagVariant, Union(alts), Tuple(...))
  * `CoercionGraph`, `CastTable`, `OverloadSet`.
* `sema/`:

  * `SymbolTable`, `ScopeID`, `ModuleID`, `ImportIndex`.
  * `TypeCtx` с арендой типов, таблицами `ExprID -> TypeID`.
  * `BorrowChecker` (интервалы заимствований, конфликты).
  * `GenericCtx` (шаблон → инстанс).
* `diag/`:

  * каталоги ошибок из спецификации (match exhaustiveness, unknown attribute targets, касты и т.д.) для единообразия. 

---

## Приёмочный чек-лист (сверху вниз)

1. ⚠️ Без перегрузок большинство модулей типизируются (операторы/return/массивы/refs), но вызовы функций ещё не получают типы — ждём call-resolver. 
2. ⚠️ Borrow-конфликты и `spawn` уже отслеживаются, но нет ограничений на Copy/own-переносы и межпоточные перемещения вне `spawn`. 
3. ✅ `Option/Result` типизируются строго, есть отдельные проверки и тесты (`internal/sema/option_result_test.go`). 
4. ⛔️ Перегрузочный резолвер отсутствует. 
5. ⚠️ `Ident(...)` vs конструктор ловим, но исчерпываемость `compare` по тэгам ещё не проверяется. 
6. ⛔️ Валидация атрибутов не реализована (кроме `@intrinsic/@override/@overload`). 
7. ⚠️ `to` работает через `__to`/intrinsics, но спец-ошибки не внедрены. 
8. ⛔️ Нет контроля циклов/дефолтов для top-level `let`. 
9. ⛔️ `signal` не проверяет @pure и зависимости. 
10. ⛔️ Директивы пока не отделены от основной типизации, проверки отсутствуют. 
