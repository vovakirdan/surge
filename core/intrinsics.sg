pragma module, no_std;

pub type byte = uint8;

@intrinsic fn rt_alloc(size: uint, align: uint) -> *byte;
@intrinsic fn rt_free(ptr: *byte, size: uint, align: uint) -> nothing;
@intrinsic fn rt_realloc(ptr: *byte, old_size: uint, new_size: uint, align: uint) -> *byte;
@intrinsic fn rt_memcpy(dst: *byte, src: *byte, n: uint) -> nothing;
@intrinsic fn rt_memmove(dst: *byte, src: *byte, n: uint) -> nothing;

// I/O primitives
@intrinsic fn rt_write_stdout(ptr: *byte, length: uint) -> uint;
@intrinsic fn rt_read_stdin(buf: *byte, max_len: uint) -> uint;

// String access intrinsics
@intrinsic fn rt_string_ptr(s: string) -> *byte;
@intrinsic fn rt_string_len(s: string) -> uint;
@intrinsic fn rt_string_from_bytes(ptr: *byte, length: uint) -> string;

// Higher-level I/O
@intrinsic
pub fn readline() -> string;

pub type Range<T> = {
    __state: *byte,
};

extern<Range<T>> {
    @intrinsic pub fn next(self: &mut Range<T>) -> Option<T>;
}

pub type Task<T> = {
    __opaque: int,
};

extern<Task<T>> {
    @intrinsic pub fn await(self: Task<T>) -> T;
}

// Cooperative yield point for CPU-bound work
// Allows scheduler to check for cancellation and yield to other tasks
@intrinsic
pub fn checkpoint() -> Task<nothing>;

// Typed channel for inter-task communication
pub type Channel<T> = {
    __opaque: *byte,
};

extern<Channel<T>> {
    // Create a new channel with given capacity (0 = unbuffered)
    @intrinsic pub fn new(capacity: uint) -> own Channel<T>;
    // Blocking send - suspends until channel has capacity
    @intrinsic pub fn send(self: &Channel<T>, value: own T) -> nothing;
    // Blocking receive - suspends until value available, returns Nothing if closed
    @intrinsic pub fn recv(self: &Channel<T>) -> Option<T>;
    // Non-blocking send - returns false if channel full
    @intrinsic pub fn try_send(self: &Channel<T>, value: own T) -> bool;
    // Non-blocking receive - returns Nothing if channel empty
    @intrinsic pub fn try_recv(self: &Channel<T>) -> Option<T>;
    // Close the channel - no more values can be sent
    @intrinsic pub fn close(self: &Channel<T>) -> nothing;
}

@intrinsic
fn make_channel<T>(capacity: uint) -> own Channel<T>;

pub contract Bounded<T> {
    fn __min_value() -> T;
    fn __max_value() -> T;
}

pub contract HasLength<T> {
    fn __len(self: &T) -> uint;
}

extern<int> {
    @intrinsic fn __add(self: int, other: int) -> int;
    @intrinsic fn __sub(self: int, other: int) -> int;
    @intrinsic fn __mul(self: int, other: int) -> int;
    @intrinsic fn __div(self: int, other: int) -> int;
    @intrinsic fn __mod(self: int, other: int) -> int;
    @intrinsic fn __bit_and(self: int, other: int) -> int;
    @intrinsic fn __bit_or(self: int, other: int) -> int;
    @intrinsic fn __bit_xor(self: int, other: int) -> int;
    @intrinsic fn __shl(self: int, other: int) -> int;
    @intrinsic fn __shr(self: int, other: int) -> int;
    @intrinsic fn __lt(self: int, other: int) -> bool;
    @intrinsic fn __le(self: int, other: int) -> bool;
    @intrinsic fn __eq(self: int, other: int) -> bool;
    @intrinsic fn __ne(self: int, other: int) -> bool;
    @intrinsic fn __ge(self: int, other: int) -> bool;
    @intrinsic fn __gt(self: int, other: int) -> bool;
    @intrinsic fn __pos(self: int) -> int;
    @intrinsic fn __neg(self: int) -> int;
    @intrinsic fn __abs(self: int) -> int;
    @intrinsic fn __to(self: int, target: string) -> string;
    @intrinsic @overload fn __to(self: int, target: float) -> float;
    @intrinsic @overload fn __to(self: int, target: uint) -> uint;
    @intrinsic @overload fn __to(self: int, target: int8) -> int8;
    @intrinsic @overload fn __to(self: int, target: int16) -> int16;
    @intrinsic @overload fn __to(self: int, target: int32) -> int32;
    @intrinsic @overload fn __to(self: int, target: int64) -> int64;
    @intrinsic @overload fn __to(self: int, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: int, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: int, target: uint32) -> uint32;
    @intrinsic @overload fn __to(self: int, target: uint64) -> uint64;
    @intrinsic @overload fn __to(self: int, target: float32) -> float32;
    @intrinsic @overload fn __to(self: int, target: float64) -> float64;
    // Parse int from string (for @entrypoint("argv") support)
    @intrinsic pub fn from_str(s: string) -> Erring<int, Error>;
}

extern<uint> {
    @intrinsic fn __add(self: uint, other: uint) -> uint;
    @intrinsic fn __sub(self: uint, other: uint) -> uint;
    @intrinsic fn __mul(self: uint, other: uint) -> uint;
    @intrinsic fn __div(self: uint, other: uint) -> uint;
    @intrinsic fn __mod(self: uint, other: uint) -> uint;
    @intrinsic fn __bit_and(self: uint, other: uint) -> uint;
    @intrinsic fn __bit_or(self: uint, other: uint) -> uint;
    @intrinsic fn __bit_xor(self: uint, other: uint) -> uint;
    @intrinsic fn __shl(self: uint, other: uint) -> uint;
    @intrinsic fn __shr(self: uint, other: uint) -> uint;
    @intrinsic fn __lt(self: uint, other: uint) -> bool;
    @intrinsic fn __le(self: uint, other: uint) -> bool;
    @intrinsic fn __eq(self: uint, other: uint) -> bool;
    @intrinsic fn __ne(self: uint, other: uint) -> bool;
    @intrinsic fn __ge(self: uint, other: uint) -> bool;
    @intrinsic fn __gt(self: uint, other: uint) -> bool;
    @intrinsic fn __pos(self: uint) -> uint;
    @intrinsic fn __abs(self: uint) -> uint;
    @intrinsic fn __to(self: uint, target: string) -> string;
    @intrinsic @overload fn __to(self: uint, target: int) -> int;
    @intrinsic @overload fn __to(self: uint, target: float) -> float;
    @intrinsic @overload fn __to(self: uint, target: int8) -> int8;
    @intrinsic @overload fn __to(self: uint, target: int16) -> int16;
    @intrinsic @overload fn __to(self: uint, target: int32) -> int32;
    @intrinsic @overload fn __to(self: uint, target: int64) -> int64;
    @intrinsic @overload fn __to(self: uint, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: uint, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: uint, target: uint32) -> uint32;
    @intrinsic @overload fn __to(self: uint, target: uint64) -> uint64;
    @intrinsic @overload fn __to(self: uint, target: float32) -> float32;
    @intrinsic @overload fn __to(self: uint, target: float64) -> float64;
    // Parse uint from string (for @entrypoint("argv") support)
    @intrinsic pub fn from_str(s: string) -> Erring<uint, Error>;
}

extern<int8> {
    pub fn __min_value() -> int8 { return (-128):int8; }
    pub fn __max_value() -> int8 { return (127):int8; }
    @intrinsic fn __to(self: int8, target: int) -> int;
    @intrinsic pub fn from_str(s: string) -> Erring<int8, Error>;
}

extern<int16> {
    pub fn __min_value() -> int16 { return (-32_768):int16; }
    pub fn __max_value() -> int16 { return (32_767):int16; }
    @intrinsic fn __to(self: int16, target: int) -> int;
    @intrinsic pub fn from_str(s: string) -> Erring<int16, Error>;
}

extern<int32> {
    pub fn __min_value() -> int32 { return (-2_147_483_648):int32; }
    pub fn __max_value() -> int32 { return (2_147_483_647):int32; }
    @intrinsic fn __to(self: int32, target: int) -> int;
    @intrinsic pub fn from_str(s: string) -> Erring<int32, Error>;
}

extern<int64> {
    pub fn __min_value() -> int64 { return (-9_223_372_036_854_775_808):int64; }
    pub fn __max_value() -> int64 { return (9_223_372_036_854_775_807):int64; }
    @intrinsic fn __to(self: int64, target: int) -> int;
    @intrinsic pub fn from_str(s: string) -> Erring<int64, Error>;
}

extern<uint8> {
    pub fn __min_value() -> uint8 { return (0):uint8; }
    pub fn __max_value() -> uint8 { return (255):uint8; }
    @intrinsic fn __to(self: uint8, target: uint) -> uint;
    @intrinsic pub fn from_str(s: string) -> Erring<uint8, Error>;
}

extern<uint16> {
    pub fn __min_value() -> uint16 { return (0):uint16; }
    pub fn __max_value() -> uint16 { return (65_535):uint16; }
    @intrinsic fn __to(self: uint16, target: uint) -> uint;
    @intrinsic pub fn from_str(s: string) -> Erring<uint16, Error>;
}

extern<uint32> {
    pub fn __min_value() -> uint32 { return (0):uint32; }
    pub fn __max_value() -> uint32 { return (4_294_967_295):uint32; }
    @intrinsic fn __to(self: uint32, target: uint) -> uint;
    @intrinsic pub fn from_str(s: string) -> Erring<uint32, Error>;
}

extern<uint64> {
    pub fn __min_value() -> uint64 { return (0):uint64; }
    pub fn __max_value() -> uint64 { return (18_446_744_073_709_551_615):uint64; }
    @intrinsic fn __to(self: uint64, target: uint) -> uint;
    @intrinsic pub fn from_str(s: string) -> Erring<uint64, Error>;
}

extern<float32> {
    pub fn __min_value() -> float32 { return (-3.402_823_466_385_2886e+38):float32; }
    pub fn __max_value() -> float32 { return (3.402_823_466_385_2886e+38):float32; }
    @intrinsic fn __to(self: float32, target: float) -> float;
    @intrinsic pub fn from_str(s: string) -> Erring<float32, Error>;
}

extern<float64> {
    pub fn __min_value() -> float64 { return (-1.797_693_134_862_3157e+308):float64; }
    pub fn __max_value() -> float64 { return (1.797_693_134_862_3157e+308):float64; }
    @intrinsic fn __to(self: float64, target: float) -> float;
    @intrinsic pub fn from_str(s: string) -> Erring<float64, Error>;
}

extern<float> {
    @intrinsic fn __add(self: float, other: float) -> float;
    @intrinsic fn __sub(self: float, other: float) -> float;
    @intrinsic fn __mul(self: float, other: float) -> float;
    @intrinsic fn __div(self: float, other: float) -> float;
    @intrinsic fn __mod(self: float, other: float) -> float;
    @intrinsic fn __lt(self: float, other: float) -> bool;
    @intrinsic fn __le(self: float, other: float) -> bool;
    @intrinsic fn __eq(self: float, other: float) -> bool;
    @intrinsic fn __ne(self: float, other: float) -> bool;
    @intrinsic fn __ge(self: float, other: float) -> bool;
    @intrinsic fn __gt(self: float, other: float) -> bool;
    @intrinsic fn __pos(self: float) -> float;
    @intrinsic fn __neg(self: float) -> float;
    @intrinsic fn __abs(self: float) -> float;
    @intrinsic fn __to(self: float, target: string) -> string;
    @intrinsic @overload fn __to(self: float, target: int) -> int;
    @intrinsic @overload fn __to(self: float, target: uint) -> uint;
    @intrinsic @overload fn __to(self: float, target: int8) -> int8;
    @intrinsic @overload fn __to(self: float, target: int16) -> int16;
    @intrinsic @overload fn __to(self: float, target: int32) -> int32;
    @intrinsic @overload fn __to(self: float, target: int64) -> int64;
    @intrinsic @overload fn __to(self: float, target: uint8) -> uint8;
    @intrinsic @overload fn __to(self: float, target: uint16) -> uint16;
    @intrinsic @overload fn __to(self: float, target: uint32) -> uint32;
    @intrinsic @overload fn __to(self: float, target: uint64) -> uint64;
    @intrinsic @overload fn __to(self: float, target: float32) -> float32;
    @intrinsic @overload fn __to(self: float, target: float64) -> float64;
    // Parse float from string (for @entrypoint("argv") support)
    @intrinsic pub fn from_str(s: string) -> Erring<float, Error>;
}

extern<string> {
    @intrinsic fn __add(self: string, other: string) -> string;
    @intrinsic fn __mul(self: string, other: int) -> string;
    @overload fn __mul(self: string, other: uint) -> string {
        return self * (other to int);
    }
    @intrinsic fn __eq(self: string, other: string) -> bool;
    @intrinsic fn __ne(self: string, other: string) -> bool;
    @intrinsic fn __to(self: string, target: int) -> int;
    @intrinsic @overload fn __to(self: string, target: uint) -> uint;
    @intrinsic @overload fn __to(self: string, target: float) -> float;
    @intrinsic fn __len(self: &string) -> uint;
    @intrinsic fn __clone(self: &string) -> string;
    // String identity (for @entrypoint("argv") support)
    pub fn from_str(s: string) -> Erring<string, Error> {
        return Success(s);
    }
}

extern<bool> {
    @intrinsic fn __eq(self: bool, other: bool) -> bool;
    @intrinsic fn __ne(self: bool, other: bool) -> bool;
    @intrinsic fn __not(self: bool) -> bool;
    @intrinsic fn __to(self: bool, target: string) -> string;
    @intrinsic @overload fn __to(self: bool, target: int) -> int;
    // Parse bool from string (for @entrypoint("argv") support)
    @intrinsic pub fn from_str(s: string) -> Erring<bool, Error>;
}

extern<Array<T>> {
    @intrinsic fn __add(self: Array<T>, other: Array<T>) -> Array<T>;
    @intrinsic fn __index(self: Array<T>, index: int) -> T;
    @intrinsic fn __index_set(self: Array<T>, index: int, value: T) -> nothing;
    @intrinsic fn __range(self: Array<T>) -> Range<T>;
    @intrinsic fn __len(self: &Array<T>) -> uint;
}

extern<ArrayFixed<T, N>> {
    @intrinsic fn __add(self: ArrayFixed<T, N>, other: ArrayFixed<T, N>) -> ArrayFixed<T, N>;
    @intrinsic fn __index(self: ArrayFixed<T, N>, index: int) -> T;
    @intrinsic fn __index_set(self: ArrayFixed<T, N>, index: int, value: T) -> nothing;
    @intrinsic fn __range(self: ArrayFixed<T, N>) -> Range<T>;
    @intrinsic fn __len(self: &ArrayFixed<T, N>) -> uint;
}

@intrinsic
pub fn default<T>() -> T;

@intrinsic
pub fn size_of<T>() -> uint;

@intrinsic
pub fn align_of<T>() -> uint;

pub contract ErrorLike{
    field message: string;
    field code: uint;
}

@intrinsic
pub fn exit<E: ErrorLike>(e: E) -> nothing;

pub fn panic(msg: string) -> nothing {
    let e: Error = { message: msg, code: 1:uint };
    exit(e);
}

pub type Mutex = {
    __opaque: *byte,
};

extern<Mutex> {
    @intrinsic pub fn new() -> Mutex;
    @intrinsic pub fn lock(self: &mut Mutex) -> nothing;
    @intrinsic pub fn unlock(self: &mut Mutex) -> nothing;
    @intrinsic pub fn try_lock(self: &mut Mutex) -> bool;
}

pub type RwLock = {
    __opaque: *byte,
};

extern<RwLock> {
    @intrinsic pub fn new() -> RwLock;
    @intrinsic pub fn read_lock(self: &mut RwLock) -> nothing;
    @intrinsic pub fn read_unlock(self: &mut RwLock) -> nothing;
    @intrinsic pub fn write_lock(self: &mut RwLock) -> nothing;
    @intrinsic pub fn write_unlock(self: &mut RwLock) -> nothing;
    @intrinsic pub fn try_read_lock(self: &mut RwLock) -> bool;
    @intrinsic pub fn try_write_lock(self: &mut RwLock) -> bool;
}

pub type Condition = {
    __opaque: *byte,
};

extern<Condition> {
    @intrinsic pub fn new() -> Condition;
    @intrinsic pub fn wait(self: &Condition, mutex: &mut Mutex) -> nothing;
    @intrinsic pub fn notify_one(self: &Condition) -> nothing;
    @intrinsic pub fn notify_all(self: &Condition) -> nothing;
}

pub type Semaphore = {
    __opaque: *byte,
    __count: uint,
};

extern<Semaphore> {
    @intrinsic pub fn new(count: uint) -> Semaphore;
    @intrinsic pub fn acquire(self: &mut Semaphore) -> nothing;
    @intrinsic pub fn release(self: &mut Semaphore) -> nothing;
    @intrinsic pub fn try_acquire(self: &mut Semaphore) -> bool;
}

// Atomic operations for @atomic fields
// These intrinsics provide thread-safe access to atomic fields.
// All operations use sequentially-consistent (SeqCst) memory ordering,
// providing the strongest guarantees for cross-task visibility.

// Atomic load - read a value atomically
@intrinsic
pub fn atomic_load(ptr: *int) -> int;

@intrinsic
@overload
pub fn atomic_load(ptr: *uint) -> uint;

@intrinsic
@overload
pub fn atomic_load(ptr: *bool) -> bool;

// Atomic store - write a value atomically
@intrinsic
pub fn atomic_store(ptr: *int, value: int) -> nothing;

@intrinsic
@overload
pub fn atomic_store(ptr: *uint, value: uint) -> nothing;

@intrinsic
@overload
pub fn atomic_store(ptr: *bool, value: bool) -> nothing;

// Atomic exchange - atomically replace value and return old value
@intrinsic
pub fn atomic_exchange(ptr: *int, new_val: int) -> int;

@intrinsic
@overload
pub fn atomic_exchange(ptr: *uint, new_val: uint) -> uint;

@intrinsic
@overload
pub fn atomic_exchange(ptr: *bool, new_val: bool) -> bool;

// Atomic compare and exchange - atomically compare and swap
// Returns true if exchange succeeded (value was expected)
@intrinsic
pub fn atomic_compare_exchange(ptr: *int, expected: int, desired: int) -> bool;

@intrinsic
@overload
pub fn atomic_compare_exchange(ptr: *uint, expected: uint, desired: uint) -> bool;

@intrinsic
@overload
pub fn atomic_compare_exchange(ptr: *bool, expected: bool, desired: bool) -> bool;

// Atomic fetch and add - atomically add to value and return old value
@intrinsic
pub fn atomic_fetch_add(ptr: *int, delta: int) -> int;

@intrinsic
@overload
pub fn atomic_fetch_add(ptr: *uint, delta: uint) -> uint;

// Atomic fetch and subtract - atomically subtract from value and return old value
@intrinsic
pub fn atomic_fetch_sub(ptr: *int, delta: int) -> int;

@intrinsic
@overload
pub fn atomic_fetch_sub(ptr: *uint, delta: uint) -> uint;
